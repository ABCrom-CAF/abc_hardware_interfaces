/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This HAL is a work in progress */

package android.hardware.neuralnetworks@1.0;

// The types an operand can have.
// These values are the same as found in the NeuralNetworks.h file.
// When modifying, be sure to update HAL_NUM_OPERAND_TYPES in HalIntefaces.h.
enum OperandType : uint32_t {
    FLOAT16                   = 0,
    FLOAT32                   = 1,
    INT8                      = 2,
    UINT8                     = 3,
    INT16                     = 4,
    UINT16                    = 5,
    INT32                     = 6,
    UINT32                    = 7,
    TENSOR_FLOAT16            = 8,
    TENSOR_FLOAT32            = 9,
    TENSOR_QUANT8_ASYMM       = 10,
};

// The type of operations.  Unlike the operation types found in
// NeuralNetworks.h file, these specify the data type they operate on.
// This is done to simplify the work of drivers.
// TODO: Currently they are the same.  Add a conversion when finalizing the model.
// When modifying, be sure to update HAL_NUM_OPERATION_TYPES in HalIntefaces.h.
enum OperationType : uint32_t {
    AVERAGE_POOL                 = 0,
    CONCATENATION                = 1,
    CONV                         = 2,
    DEPTHWISE_CONV               = 3,
    MAX_POOL                     = 4,
    L2_POOL                      = 5,
    DEPTH_TO_SPACE               = 6,
    SPACE_TO_DEPTH               = 7,
    LOCAL_RESPONSE_NORMALIZATION = 8,
    SOFTMAX                      = 9,
    RESHAPE                      = 10,
    SPLIT                        = 11,
    FAKE_QUANT                   = 12,
    ADD                          = 13,
    FULLY_CONNECTED              = 14,
    CAST                         = 15,
    MUL                          = 16,
    L2_NORMALIZATION             = 17,
    LOGISTIC                     = 18,
    RELU                         = 19,
    RELU6                        = 20,
    RELU1                        = 21,
    TANH                         = 22,
    DEQUANTIZE                   = 23,
    FLOOR                        = 24,
    GATHER                       = 25,
    RESIZE_BILINEAR              = 26,
    LSH_PROJECTION               = 27,
    LSTM                         = 28,
    SVDF                         = 29,
    RNN                          = 30,
    N_GRAM                       = 31,
    LOOKUP                       = 32,
};

// Two special values that can be used instead of a regular poolIndex.
enum LocationValues : uint32_t {
    // The location will be specified at runtime. It's either a temporary
    // variable, an input, or an output.
    LOCATION_AT_RUN_TIME = 0xFFFFFFFF,
    // The operand's value is stored in the
    // TODO: Only for old
    LOCATION_SAME_BLOCK = 0xFFFFFFFE
};

// Status of a device.
enum DeviceStatus : uint32_t {
    AVAILABLE,
    BUSY,
    OFFLINE,
    UNKNOWN  // Do we need this?
};

// For the reference workload
// Used by a driver to report its performance characteristics.
// TODO revisit the data types and scales.
struct PerformanceInfo {
    float execTime;    // in nanoseconds
    float powerUsage;  // in picoJoules
};

struct OperationTuple {
    // The type of operation.
    OperationType operationType;
    // The input data type of operation.
    OperandType operandType;
};

// The capabilities of a driver.
struct Capabilities {
    vec<OperationTuple> supportedOperationTuples;
    // TODO Do the same for baseline model IDs
    bool cachesCompilation;
    // TODO revisit the data types and scales.
    float bootupTime;  // in nanoseconds
    PerformanceInfo float16Performance;
    PerformanceInfo float32Performance;
    PerformanceInfo quantized8Performance;
};

// Describes the location of a data object.
struct DataLocation {
    // The index of the memory pool where this location is found.
    // Two special values can also be used.  See the LOCATION_* constants above.
    uint32_t poolIndex;
    // Offset in bytes from the start of the pool.
    uint32_t offset;
    // The length of the data, in bytes.
    uint32_t length;
};

struct Operand {
    OperandType type;
    vec<uint32_t> dimensions;

    // The number of operations that uses this operand as input.
    // TODO It would be nice to track the actual consumers, e.g. vec<uint32_t> consumers;
    uint32_t numberOfConsumers;

    float scale;
    int32_t zeroPoint;

    // Where to find the data for this operand.
    DataLocation location;
};

// Describes one operation of the graph.
struct Operation {
    // The tuple describing the operation type and input type.
    OperationTuple opTuple;
    // Describes the table that contains the indexes of the inputs of the
    // operation. The offset is the index in the operandIndexes table.
    vec<uint32_t> inputs;
    // Describes the table that contains the indexes of the outputs of the
    // operation. The offset is the index in the operandIndexes table.
    vec<uint32_t> outputs;
};

struct InputOutputInfo {
    DataLocation location;
    // If dimensions.size() > 0, we have updated dimensions.
    vec<uint32_t> dimensions;
};

struct Model {
    vec<Operand> operands;
    vec<Operation> operations;
    vec<uint32_t> inputIndexes;
    vec<uint32_t> outputIndexes;
    vec<uint8_t> operandValues;
    vec<memory> pools;
};

struct Request {
    vec<InputOutputInfo> inputs;
    vec<InputOutputInfo> outputs;
    vec<memory> pools;
};
