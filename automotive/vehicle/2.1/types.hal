/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.1 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.1
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.automotive.vehicle@2.1;

import android.hardware.automotive.vehicle@2.0;

/**
 * Extension of VehicleProperty enum declared in Vehicle HAL 2.0
 */
enum VehicleProperty: @2.0::VehicleProperty {
    /**
     * Reports wheel ticks
     *
     * The first four elements represent ticks for individual wheels in the
     * following order: front left, front right, rear right, rear left.  All
     * tick counts are cumulative.  Tick counts increment when the vehicle
     * moves forward, and decrement when vehicles moves in reverse.  The ticks
     * should be reset to 0 when the vehicle is started by the user.
     *
     * The next element in the vector is a reset count.  A reset indicates
     * previous tick counts are not comparable with this and future ones.  Some
     * sort of discontinuity in tick counting has occurred.
     *
     *  int64Values[0] = reset count
     *  int64Values[1] = front left ticks
     *  int64Values[2] = front right ticks
     *  int64Values[3] = rear right ticks
     *  int64Values[4] = rear left ticks
     *
     * configArray is used to indicate the micrometers-per-wheel-tick value as well as
     * which wheels are supported.  configArray is set as follows:
     *
     *  configArray[0], bits [0:3] = supported wheels.  Uses enum Wheel.
     *  configArray[1] = micrometers per front left wheel tick
     *  configArray[2] = micrometers per front right wheel tick
     *  configArray[3] = micrometers per rear right wheel tick
     *  configArray[4] = micrometers per rear left wheel tick
     *
     * NOTE:  If a wheel is not supported, its value shall always be set to 0.
     *
     * VehiclePropValue.timestamp must be correctly filled in.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     */
    WHEEL_TICK = (
      0x0306
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * ABS is active.  Set to true whenever ABS is activated.  Reset to false when ABS is off.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    ABS_ACTIVE = (
        0x040A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Traction Control is active.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TRACTION_CONTROL_ACTIVE = (
        0x040B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Automatic re-circulation on/off
     *
     * IVehicle#set and IVehicle#get must return StatusCode::NOT_AVAILABLE when HVAC unit is off.
     * See HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_RECIRC_ON = (
        0x0512
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Vehicle Maps Service (VMS) message
     *
     * This property uses COMPLEX data to communicate vms messages.
     *
     * Its contents are to be interpreted as follows:
     * the indices defined in VmsMessageIntegerValuesIndex are to be used to
     * read from int32Values;
     * bytes is a serialized VMS message as defined in the vms protocol
     * which is opaque to the framework;
     *
     * IVehicle#get must always return StatusCode::NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    VEHICLE_MAP_SERVICE = (
        0x0C00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:COMPLEX
        | VehicleArea:GLOBAL),

    /**
     * OBD2 Live Sensor Data
     *
     * Reports a snapshot of the current (live) values of the OBD2 sensors available.
     *
     * The configArray is set as follows:
     *   configArray[0] = number of vendor-specific integer-valued sensors
     *   configArray[1] = number of vendor-specific float-valued sensors
     *
     * The values of this property are to be interpreted as in the following example.
     * Considering a configArray = {2,3}
     * int32Values must be a vector containing Obd2IntegerSensorIndex.LAST_SYSTEM_INDEX + 2
     * elements (that is, 33 elements);
     * floatValues must be a vector containing Obd2FloatSensorIndex.LAST_SYSTEM_INDEX + 3
     * elements (that is, 73 elements);
     *
     * It is possible for each frame to contain a different subset of sensor values, both system
     * provided sensors, and vendor-specific ones. In order to support that, the bytes element
     * of the property value is used as a bitmask,.
     *
     * bytes must have a sufficient number of bytes to represent the total number of possible
     * sensors (in this case, 14 bytes to represent 106 possible values); it is to be read as
     * a contiguous bitmask such that each bit indicates the presence or absence of a sensor
     * from the frame, starting with as many bits as the size of int32Values, immediately
     * followed by as many bits as the size of floatValues.
     *
     * For example, should bytes[0] = 0x4C (0b01001100) it would mean that:
     *   int32Values[0 and 1] are not valid sensor values
     *   int32Values[2 and 3] are valid sensor values
     *   int32Values[4 and 5] are not valid sensor values
     *   int32Values[6] is a valid sensor value
     *   int32Values[7] is not a valid sensor value
     * Should bytes[5] = 0x61 (0b01100001) it would mean that:
     *   int32Values[32] is a valid sensor value
     *   floatValues[0 thru 3] are not valid sensor values
     *   floatValues[4 and 5] are valid sensor values
     *   floatValues[6] is not a valid sensor value
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_LIVE_FRAME = (
      0x0D00
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Sensor Data
     *
     * Reports a snapshot of the value of the OBD2 sensors available at the time that a fault
     * occurred and was detected.
     *
     * A configArray must be provided with the same meaning as defined for OBD2_LIVE_FRAME.
     *
     * The values of this property are to be interpreted in a similar fashion as those for
     * OBD2_LIVE_FRAME, with the exception that the stringValue field may contain a non-empty
     * diagnostic troubleshooting code (DTC).
     *
     * A IVehicle#get request of this property must provide a value for int64Values[0].
     * This will be interpreted as the timestamp of the freeze frame to retrieve. A list of
     * timestamps can be obtained by a IVehicle#get of OBD2_FREEZE_FRAME_INFO.
     *
     * Should no freeze frame be available at the given timestamp, a response of NOT_AVAILABLE
     * must be returned by the implementation. Because vehicles may have limited storage for
     * freeze frames, it is possible for a frame request to respond with NOT_AVAILABLE even if
     * the associated timestamp has been recently obtained via OBD2_FREEZE_FRAME_INFO.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME = (
      0x0D01
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Information
     *
     * This property describes the current freeze frames stored in vehicle
     * memory and available for retrieval via OBD2_FREEZE_FRAME.
     *
     * The values are to be interpreted as follows:
     * each element of int64Values must be the timestamp at which a a fault code
     * has been detected and the corresponding freeze frame stored, and each
     * such element can be used as the key to OBD2_FREEZE_FRAME to retrieve
     * the corresponding freeze frame.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME_INFO = (
      0x0D02
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Clear
     *
     * This property allows deletion of any of the freeze frames stored in
     * vehicle memory, as described by OBD2_FREEZE_FRAME_INFO.
     *
     * The configArray is set as follows:
     *  configArray[0] = 1 if the implementation is able to clear individual freeze frames
     *                   by timestamp, 0 otherwise
     *
     * IVehicle#set of this property is to be interpreted as follows:
     *   if int64Values contains no elements, then all frames stored must be cleared;
     *   if int64Values contains one or more elements, then frames at the timestamps
     *   stored in int64Values must be cleared, and the others not cleared. Should the
     *   vehicle not support selective clearing of freeze frames, this latter mode must
     *   return NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    OBD2_FREEZE_FRAME_CLEAR = (
      0x0D03
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:COMPLEX
      | VehicleArea:GLOBAL),
};

/**
 * The status of the vehicle's fuel system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelSystemStatus : int32_t {
  OPEN_INSUFFICIENT_ENGINE_TEMPERATURE = 1,
  CLOSED_LOOP = 2,
  OPEN_ENGINE_LOAD_OR_DECELERATION = 4,
  OPEN_SYSTEM_FAILURE = 8,
  CLOSED_LOOP_BUT_FEEDBACK_FAULT = 16,
};

/** Defines which ignition monitors are available to be read. */
enum Obd2IgnitionMonitorKind : int32_t {
  SPARK = 0,
  COMPRESSION = 1,
};

/**
 * Ignition monitors common to both SPARK and COMPRESSION.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CommonIgnitionMonitors : int32_t {
  COMPONENTS_AVAILABLE = 0x1 << 0,
  COMPONENTS_INCOMPLETE = 0x1 << 1,

  FUEL_SYSTEM_AVAILABLE = 0x1 << 2,
  FUEL_SYSTEM_INCOMPLETE = 0x1 << 3,

  MISFIRE_AVAILABLE = 0x1 << 4,
  MISFIRE_INCOMPLETE = 0x1 << 5,
};

/**
 * Ignition monitors available for SPARK vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SparkIgnitionMonitors : Obd2CommonIgnitionMonitors {
  EGR_AVAILABLE = 0x1 << 6,
  EGR_INCOMPLETE = 0x1 << 7,

  OXYGEN_SENSOR_HEATER_AVAILABLE = 0x1 << 8,
  OXYGEN_SENSOR_HEATER_INCOMPLETE = 0x1 << 9,

  OXYGEN_SENSOR_AVAILABLE = 0x1 << 10,
  OXYGEN_SENSOR_INCOMPLETE = 0x1 << 11,

  AC_REFRIGERANT_AVAILABLE = 0x1 << 12,
  AC_REFRIGERANT_INCOMPLETE = 0x1 << 13,

  SECONDARY_AIR_SYSTEM_AVAILABLE = 0x1 << 14,
  SECONDARY_AIR_SYSTEM_INCOMPLETE = 0x1 << 15,

  EVAPORATIVE_SYSTEM_AVAILABLE = 0x1 << 16,
  EVAPORATIVE_SYSTEM_INCOMPLETE = 0x1 << 17,

  HEATED_CATALYST_AVAILABLE = 0x1 << 18,
  HEATED_CATALYST_INCOMPLETE = 0x1 << 19,

  CATALYST_AVAILABLE = 0x1 << 20,
  CATALYST_INCOMPLETE = 0x1 << 21,
};

/**
 * Ignition monitors only available for COMPRESSION vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CompressionIgnitionMonitors : Obd2CommonIgnitionMonitors {
  EGR_OR_VVT_AVAILABLE = 0x1 << 6,
  EGR_OR_VVT_INCOMPLETE = 0x1 << 7,

  PM_FILTER_AVAILABLE = 0x1 << 8,
  PM_FILTER_INCOMPLETE = 0x1 << 9,

  EXHAUST_GAS_SENSOR_AVAILABLE = 0x1 << 10,
  EXHAUST_GAS_SENSOR_INCOMPLETE = 0x1 << 11,

  BOOST_PRESSURE_AVAILABLE = 0x1 << 12,
  BOOST_PRESSURE_INCOMPLETE = 0x1 << 13,

  NOx_SCR_AVAILABLE = 0x1 << 14,
  NOx_SCR_INCOMPLETE = 0x1 << 15,

  NMHC_CATALYST_AVAILABLE = 0x1 << 16,
  NMHC_CATALYST_INCOMPLETE = 0x1 << 17,
};

/**
 * The status of the vehicle's secondary air system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SecondaryAirStatus : int32_t {
  UPSTREAM = 1,
  DOWNSTREAM_OF_CATALYCIC_CONVERTER = 2,
  FROM_OUTSIDE_OR_OFF = 4,
  PUMP_ON_FOR_DIAGNOSTICS = 8,
};

/**
 * The fuel type(s) supported by a vehicle.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelType : int32_t {
  NOT_AVAILABLE = 0,
  GASOLINE = 1,
  METHANOL = 2,
  ETHANOL = 3,
  DIESEL = 4,
  LPG = 5,
  CNG = 6,
  PROPANE = 7,
  ELECTRIC = 8,
  BIFUEL_RUNNING_GASOLINE = 9,
  BIFUEL_RUNNING_METHANOL = 10,
  BIFUEL_RUNNING_ETHANOL = 11,
  BIFUEL_RUNNING_LPG = 12,
  BIFUEL_RUNNING_CNG = 13,
  BIFUEL_RUNNING_PROPANE = 14,
  BIFUEL_RUNNING_ELECTRIC = 15,
  BIFUEL_RUNNING_ELECTRIC_AND_COMBUSTION = 16,
  HYBRID_GASOLINE = 17,
  HYBRID_ETHANOL = 18,
  HYBRID_DIESEL = 19,
  HYBRID_ELECTRIC = 20,
  HYBRID_RUNNING_ELECTRIC_AND_COMBUSTION = 21,
  HYBRID_REGENERATIVE = 22,
  BIFUEL_RUNNING_DIESEL = 23,
};

/**
 * This enum provides the canonical mapping for sensor properties that have an integer value.
 * The ordering of the values is taken from the OBD2 specification.
 * Some of the properties are represented as an integer mapping to another enum. In those cases
 * expect a comment by the property definition describing the enum to look at for the mapping.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticIntegerSensorIndex : int32_t {
  /** refer to FuelSystemStatus for a description of this value. */
  FUEL_SYSTEM_STATUS = 0, /* PID 0x03 */
  MALFUNCTION_INDICATOR_LIGHT_ON = 1, /* PID 0x01 */

  /** refer to IgnitionMonitorKind for a description of this value. */
  IGNITION_MONITORS_SUPPORTED = 2, /* PID 0x01 */

  /**
   * The value of this sensor is a bitmask that specifies whether ignition-specific
   * tests are available and whether they are complete. The semantics of the individual
   * bits in this value are given by, respectively, SparkIgnitionMonitors and
   * CompressionIgnitionMonitors depending on the value of IGNITION_MONITORS_SUPPORTED.
   */
  IGNITION_SPECIFIC_MONITORS = 3, /* PID 0x01 */
  INTAKE_AIR_TEMPERATURE = 4, /* PID 0x0F */

  /** refer to SecondaryAirStatus for a description of this value. */
  COMMANDED_SECONDARY_AIR_STATUS = 5, /* PID 0x12 */
  NUM_OXYGEN_SENSORS_PRESENT = 6, /* PID 0x13 */
  RUNTIME_SINCE_ENGINE_START = 7, /* PID 0x1F */
  DISTANCE_TRAVELED_WITH_MALFUNCTION_INDICATOR_LIGHT_ON = 8, /* PID 0x21 */
  WARMUPS_SINCE_CODES_CLEARED = 9, /* PID 0x30 */
  DISTANCE_TRAVELED_SINCE_CODES_CLEARED = 10, /* PID 0x31 */
  ABSOLUTE_BAROMETRIC_PRESSURE = 11, /* PID 0x33 */
  CONTROL_MODULE_VOLTAGE = 12, /* PID 0x42 */
  AMBIENT_AIR_TEMPERATURE = 13, /* PID 0x46 */
  TIME_WITH_MALFUNCTION_LIGHT_ON = 14, /* PID 0x4D */
  TIME_SINCE_TROUBLE_CODES_CLEARED = 15, /* PID 0x4E */
  MAX_FUEL_AIR_EQUIVALENCE_RATIO = 16, /* PID 0x4F */
  MAX_OXYGEN_SENSOR_VOLTAGE = 17, /* PID 0x4F */
  MAX_OXYGEN_SENSOR_CURRENT = 18, /* PID 0x4F */
  MAX_INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 19, /* PID 0x4F */
  MAX_AIR_FLOW_RATE_FROM_MASS_AIR_FLOW_SENSOR = 20, /* PID 0x50 */

  /** refer to FuelType for a description of this value. */
  FUEL_TYPE = 21, /* PID 0x51 */
  FUEL_RAIL_ABSOLUTE_PRESSURE = 22, /* PID 0x59 */
  ENGINE_OIL_TEMPERATURE = 23, /* PID 0x5C */
  DRIVER_DEMAND_PERCENT_TORQUE = 24, /* PID 0x61 */
  ENGINE_ACTUAL_PERCENT_TORQUE = 25, /* PID 0x62 */
  ENGINE_REFERENCE_PERCENT_TORQUE = 26, /* PID 0x63 */
  ENGINE_PERCENT_TORQUE_DATA_IDLE = 27, /* PID 0x64 */
  ENGINE_PERCENT_TORQUE_DATA_POINT1 = 28, /* PID 0x64 */
  ENGINE_PERCENT_TORQUE_DATA_POINT2 = 29, /* PID 0x64 */
  ENGINE_PERCENT_TORQUE_DATA_POINT3 = 30, /* PID 0x64 */
  ENGINE_PERCENT_TORQUE_DATA_POINT4 = 31, /* PID 0x64 */
  LAST_SYSTEM_INDEX = ENGINE_PERCENT_TORQUE_DATA_POINT4,
};

/**
 * This enum provides the canonical mapping for sensor properties that have a floating-point value.
 * The ordering of the values is taken from the OBD2 specification.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticFloatSensorIndex : int32_t {
  CALCULATED_ENGINE_LOAD = 0, /* PID 0x04 */
  ENGINE_COOLANT_TEMPERATURE = 1, /* PID 0x05 */
  SHORT_TERM_FUEL_TRIM_BANK1 = 2, /* PID 0x06 */
  LONG_TERM_FUEL_TRIM_BANK1 = 3, /* PID 0x07 */
  SHORT_TERM_FUEL_TRIM_BANK2 = 4, /* PID 0x08 */
  LONG_TERM_FUEL_TRIM_BANK2 = 5, /* PID 0x09 */
  FUEL_PRESSURE = 6, /* PID 0x0A */
  INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 7, /* PID 0x0B */
  ENGINE_RPM = 8, /* PID 0x0C */
  VEHICLE_SPEED = 9, /* PID 0x0D */
  TIMING_ADVANCE = 10, /* PID 0x0E */
  MAF_AIR_FLOW_RATE = 11, /* PID 0x10 */
  THROTTLE_POSITION = 12, /* PID 0x11 */
  OXYGEN_SENSOR1_VOLTAGE = 13, /* PID 0x14 */
  OXYGEN_SENSOR1_SHORT_TERM_FUEL_TRIM = 14, /* PID 0x14 */
  OXYGEN_SENSOR1_FUEL_AIR_EQUIVALENCE_RATIO = 15, /* PID 0x24 */
  OXYGEN_SENSOR2_VOLTAGE = 16, /* PID 0x15 */
  OXYGEN_SENSOR2_SHORT_TERM_FUEL_TRIM = 17, /* PID 0x15 */
  OXYGEN_SENSOR2_FUEL_AIR_EQUIVALENCE_RATIO = 18, /* PID 0x25 */
  OXYGEN_SENSOR3_VOLTAGE = 19, /* PID 0x16 */
  OXYGEN_SENSOR3_SHORT_TERM_FUEL_TRIM = 20, /* PID 0x16 */
  OXYGEN_SENSOR3_FUEL_AIR_EQUIVALENCE_RATIO = 21, /* PID 0x26 */
  OXYGEN_SENSOR4_VOLTAGE = 22, /* PID 0x17 */
  OXYGEN_SENSOR4_SHORT_TERM_FUEL_TRIM = 23, /* PID 0x17 */
  OXYGEN_SENSOR4_FUEL_AIR_EQUIVALENCE_RATIO = 24, /* PID 0x27 */
  OXYGEN_SENSOR5_VOLTAGE = 25, /* PID 0x18 */
  OXYGEN_SENSOR5_SHORT_TERM_FUEL_TRIM = 26, /* PID 0x18 */
  OXYGEN_SENSOR5_FUEL_AIR_EQUIVALENCE_RATIO = 27, /* PID 0x28 */
  OXYGEN_SENSOR6_VOLTAGE = 28, /* PID 0x19 */
  OXYGEN_SENSOR6_SHORT_TERM_FUEL_TRIM = 29, /* PID 0x19 */
  OXYGEN_SENSOR6_FUEL_AIR_EQUIVALENCE_RATIO = 30, /* PID 0x29 */
  OXYGEN_SENSOR7_VOLTAGE = 31, /* PID 0x1A */
  OXYGEN_SENSOR7_SHORT_TERM_FUEL_TRIM = 32, /* PID 0x1A */
  OXYGEN_SENSOR7_FUEL_AIR_EQUIVALENCE_RATIO = 33, /* PID 0x2A */
  OXYGEN_SENSOR8_VOLTAGE = 34, /* PID 0x1B */
  OXYGEN_SENSOR8_SHORT_TERM_FUEL_TRIM = 35, /* PID 0x1B */
  OXYGEN_SENSOR8_FUEL_AIR_EQUIVALENCE_RATIO = 36, /* PID 0x2B */
  FUEL_RAIL_PRESSURE = 37, /* PID 0x22 */
  FUEL_RAIL_GAUGE_PRESSURE = 38, /* PID 0x23 */
  COMMANDED_EXHAUST_GAS_RECIRCULATION = 39, /* PID 0x2C */
  EXHAUST_GAS_RECIRCULATION_ERROR = 40, /* PID 0x2D */
  COMMANDED_EVAPORATIVE_PURGE = 41, /* PID 0x2E */
  FUEL_TANK_LEVEL_INPUT = 42, /* PID 0x2F */
  EVAPORATION_SYSTEM_VAPOR_PRESSURE = 43, /* PID 0x32 */
  CATALYST_TEMPERATURE_BANK1_SENSOR1 = 44, /* PID 0x3C */
  CATALYST_TEMPERATURE_BANK2_SENSOR1 = 45, /* PID 0x3D */
  CATALYST_TEMPERATURE_BANK1_SENSOR2 = 46, /* PID 0x3E */
  CATALYST_TEMPERATURE_BANK2_SENSOR2 = 47, /* PID 0x3F */
  ABSOLUTE_LOAD_VALUE = 48, /* PID 0x43 */
  FUEL_AIR_COMMANDED_EQUIVALENCE_RATIO = 49, /* PID 0x44 */
  RELATIVE_THROTTLE_POSITION = 50, /* PID 0x45 */
  ABSOLUTE_THROTTLE_POSITION_B = 51, /* PID 0x47 */
  ABSOLUTE_THROTTLE_POSITION_C = 52, /* PID 0x48 */
  ACCELERATOR_PEDAL_POSITION_D = 53, /* PID 0x49 */
  ACCELERATOR_PEDAL_POSITION_E = 54, /* PID 0x4A */
  ACCELERATOR_PEDAL_POSITION_F = 55, /* PID 0x4B */
  COMMANDED_THROTTLE_ACTUATOR = 56, /* PID 0x4C */
  ETHANOL_FUEL_PERCENTAGE = 57,/* PID 0x52 */
  ABSOLUTE_EVAPORATION_SYSTEM_VAPOR_PRESSURE = 58, /* PID 0x53 */
  SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 59, /* PID 0x55 */
  SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 60, /* PID 0x57 */
  SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 61,/* PID 0x55 */
  SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 62, /* PID 0x57 */
  LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 63, /* PID 0x56 */
  LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 64, /* PID 0x58 */
  LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 65, /* PID 0x56 */
  LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 66, /* PID 0x58 */
  RELATIVE_ACCELERATOR_PEDAL_POSITION = 67, /* PID 0x5A */
  HYBRID_BATTERY_PACK_REMAINING_LIFE = 68, /* PID 0x5B */
  FUEL_INJECTION_TIMING = 69, /* PID 0x5D */
  ENGINE_FUEL_RATE = 70, /* PID 0x5E */
  LAST_SYSTEM_INDEX = ENGINE_FUEL_RATE,
};

/**
 * This enum lists the types of supported VMS messages. It is used as the first
 * integer in the vehicle property integers array and determines how the rest of
 * the message is decoded.
 */
enum VmsMessageType : int32_t {
  /**
   * A request from the subscribers to the VMS service to subscribe to a layer.
   *
   * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
   */
  SUBSCRIBE = 1,

  /**
   * A request from the subscribers to the VMS service to subscribe to a layer from a specific publisher.
   *
   * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
   */
  SUBSCRIBE_TO_PUBLISHER = 2,

  /**
   * A request from the subscribers to the VMS service to unsubscribes from a layer.
   *
   * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
   */
  UNSUBSCRIBE = 3,

  /**
   * A request from the subscribers to the VMS service to unsubscribes from a layer from a specific publisher.
   *
   * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
   */
  UNSUBSCRIBE_TO_PUBLISHER = 4,

  /**
   * Information from the publishers to the VMS service about the layers which the client can publish.
   *
   * This message type uses enum VmsOfferingMessageIntegerValuesIndex.
   */
  OFFERING = 5,

  /**
   * A request from the subscribers to the VMS service to get the available layers.
   *
   * This message type uses enum VmsBaseMessageIntegerValuesIndex.
   */
  AVAILABILITY_REQUEST = 6,

  /**
   * A request from the publishers to the VMS service to get the layers with subscribers.
   *
   * This message type uses enum VmsBaseMessageIntegerValuesIndex.
   */
  SUBSCRIPTIONS_REQUEST = 7,

  /**
   * A response from the VMS service to the subscribers to a VmsMessageType.AVAILABILITY_REQUEST
   *
   * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
   */
  AVAILABILITY_RESPONSE = 8,

  /**
   * A notification from the VMS service to the subscribers on a change in the available layers.
   *
   * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
   */
  AVAILABILITY_CHANGE = 9,

  /**
   * A response from the VMS service to the publishers to a VmsMessageType.SUBSCRIPTIONS_REQUEST
   *
   * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
   */
  SUBSCRIPTIONS_RESPONSE = 10,

  /**
   * A notification from the VMS service to the publishers on a change in the layers with subscribers.
   *
   * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
   */
  SUBSCRIPTIONS_CHANGE = 11,

  /**
   * A message from the VMS service to the subscribers or from the publishers to the VMS service
   * with a serialized VMS data packet as defined in the VMS protocol.
   *
   * This message type uses enum VmsBaseMessageIntegerValuesIndex.
   */
  DATA = 12,
};

/**
 * Every VMS message starts with the type of the message from the VmsMessageType enum.
 * Messages with no parameters such as VmsMessageType.AVAILABILITY_REQUEST,
 * VmsMessageType.SUBSCRIPTIONS_REQUEST and VmsMessageType.DATA are also based on this enum.
 */
enum VmsBaseMessageIntegerValuesIndex : int32_t {
  /* The message type as enumerated by VmsMessageType enum. */
  MESSAGE_TYPE = 0,
};

/*
 * A VMS message with a layer is sent as part of a VmsMessageType.SUBSCRIBE or
 * VmsMessageType.UNSUBSCRIBE messages.
 *
 * The layer type is defined in the VMS protocol, and the subtype and version are
 * controlled by the implementer of the publisher.
 */
enum VmsMessageWithLayerIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
  LAYER_TYPE = 1,

  LAYER_SUBTYPE = 2,

  LAYER_VERSION = 3,
};

/*
 * A VMS message with a layer and publisher ID is sent as part of a
 * VmsMessageType.SUBSCRIBE_TO_PUBLISHER and VmsMessageType.UNSUBSCRIBE_TO_PUBLISHER messages.
 */
enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex : VmsMessageWithLayerIntegerValuesIndex {
  PUBLISHER_ID = 4,
};

/*
 * An offering can be sent by publishers as part of VmsMessageType.OFFERING in order to
 * advertise which layers they can publish and under which constraints: e.g., I can publish Layer X
 * if someone else will publish Layer Y.
 * The offering contains the publisher ID which was assigned to the publisher by the VMS service.
 * A single offering is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of dependencies (N)
 * - N x (Layer type, Layer subtype, Layer version)
 */
enum VmsOfferingMessageIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
  PUBLISHER_ID = 1,

  NUMBER_OF_OFFERS = 2,

  OFFERING_START = 3,
};

/**
 * A subscriptions state is sent to the publishers in response to a change in the subscriptions
 * as part of a VmsMessageType.SUBSCRIPTIONS_CHANGE, or in response to a
 * VmsMessageType.SUBSCRIPTIONS_REQUEST message as part of VmsMessageType.SUBSCRIPTIONS_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number it should ignore the message.
 * The subscriptions are sent as a list of layers followed by a list of associated layers:
 * {Sequence number, N, M, N x layer, M x associated layer}
 * A subscribed layer is represented as three integers:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * A subscribed associated layer is a layer with a list of publisher IDs. It is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
 */
enum VmsSubscriptionsStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
  SEQUENCE_NUMBER = 1,

  NUMBER_OF_LAYERS = 2,

  NUMBER_OF_ASSOCIATED_LAYERS = 3,

  SUBSCRIPTIONS_START = 4,
};

/**
 * An availability state is sent to the subscribers in response to a change in the available
 * layers as part of a VmsMessageType.AVAILABILITY_CHANGE message, or in response to a
 * VmsMessageType.AVAILABILITY_REQUEST message as part of a VmsMessageType.AVAILABILITY_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number, it should ignore the message.
 * An available associated layer is a layer with a list of publisher IDs:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
*/
enum VmsAvailabilityStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
  SEQUENCE_NUMBER = 1,

  NUMBER_OF_ASSOCIATED_LAYERS = 2,

  LAYERS_START = 3,
};
