/*
 * Copyright 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.wifi@1.0;

/**
 * Enum values indicating the status of operation.
 */
enum WifiStatusCode : uint32_t {
  /** No errors. */
  SUCCESS,
  /** Method invoked on an invalid |IWifiChip| object. */
  ERROR_WIFI_CHIP_INVALID,
  /** Method invoked on an invalid |IWifiIface| object. */
  ERROR_WIFI_IFACE_INVALID,
  /** Method invoked on an invalid |IWifiRttController| object. */
  ERROR_WIFI_RTT_CONTROLLER_INVALID,
  ERROR_NOT_SUPPORTED,
  ERROR_NOT_AVAILABLE,
  ERROR_NOT_STARTED,
  ERROR_INVALID_ARGS,
  ERROR_BUSY,
  ERROR_UNKNOWN
};

/**
 * Generic structure to return the status of an operation.
 */
struct WifiStatus {
  WifiStatusCode code;
  /**
   * A vendor specific error message from the vendor to provide more
   * information beyond the reason code.
   */
  string description;
};

/**
 * List of Iface types supported.
 */
enum IfaceType : uint32_t {
  STA,
  AP,
  P2P,
  /**
   * NAN control interface. Datapath support must be queried and created
   * through this interface.
   */
  NAN,
};

/**
 * An identifier assigned to every chip on the device.
 */
typedef uint32_t ChipId;

/**
 * An identifier for a mode that the chip can be put in.
 */
typedef uint32_t ChipModeId;

/**
 * A unique handle provided by the client to identify individual invocations of
 * certain API's like |IWifiStaIface.startBackgroundScan|,
 * |IWifiStaIface.installApfPacketFilter|, etc.
 */
typedef uint32_t CommandId;

/**
 * Channel frequency in Mhz.
 */
typedef uint32_t WifiChannelInMhz;

/**
 * Channel operating width in Mhz.
 */
enum WifiChannelWidthInMhz : uint32_t {
  WIDTH_20    = 0,
  WIDTH_40    = 1,
  WIDTH_80    = 2,
  WIDTH_160   = 3,
  WIDTH_80P80 = 4,
  WIDTH_5     = 5,
  WIDTH_10    = 6,
  WIDTH_INVALID = -1
};

/**
 * Channel information.
 */
struct WifiChannelInfo {
  /**
   * Channel width (20, 40, 80, 80+80, 160).
   */
  WifiChannelWidthInMhz width;
  /**
   * Primary 20 MHz channel.
   */
  WifiChannelInMhz centerFreq;
  /**
   * Center frequency (MHz) first segment.
   */
  WifiChannelInMhz centerFreq0;
  /**
   * Center frequency (MHz) second segment.
   */
  WifiChannelInMhz centerFreq1;
};

/**
 * RSSI information.
 */
typedef int32_t Rssi;

/**
 * Mac Address type. 6 octets representing physical address of a device.
 */
typedef uint8_t[6] MacAddress;

/**
 * SSID type. 32 octets representing the network.
 */
typedef uint8_t[32] Ssid;

/**
 * BSSID type. 6 octets representing the physical address of an AP.
 */
typedef MacAddress Bssid;

/**
 * TimeStamp in milliseconds (ms).
 */
typedef uint32_t TimeStampInMs;

/**
 * TimeStamp in microseconds (us).
 */
typedef uint64_t TimeStampInUs;

/**
 * TimeStamp in picoseconds (ps).
 */
typedef uint64_t TimeSpanInPs;

/**
 * Information elements contained within the |ScanResult| structure.
 * These elements correspond to the IEEE_802.11 standard.
 */
struct WifiInformationElement {
  uint8_t id;
  vec<uint8_t> data;
};

enum WifiRatePreamble : uint32_t {
  OFDM = 0,
  CCK = 1,
  HT = 2,
  VHT = 3,
  RESERVED = 4
};

/**
 * Number of spatial streams in VHT/HT.
 */
enum WifiRateNss : uint32_t {
  NSS_1x1 = 0,
  NSS_2x2 = 1,
  NSS_3x3 = 2,
  NSS_4x4 = 3
};

/**
 * Wifi rate info.
 */
struct WifiRateInfo {
  /**
   * Preamble used for RTT measurements.
   */
  WifiRatePreamble preamble;
  /**
   * Number of spatial streams.
   */
  WifiRateNss nss;
  /**
   * Bandwidth of channel.
   */
  WifiChannelWidthInMhz bw;
  /**
   * OFDM/CCK rate code would be as per ieee std in the units of 0.5mbps.
   * HT/VHT it would be mcs index.
   */
  uint8_t rateMcsIdx;
  /**
   * Bitrate in units of 100 Kbps.
   */
  uint32_t bitRateInKbps;
};

/**
 * STA specific types.
 * TODO(b/32159498): Move to a separate nan_types.hal.
 */
/**
 * Parameters to specify the APF capabilities of this iface.
 */
struct StaApfPacketFilterCapabilities {
  /**
   * Version of the packet filter interpreter supported
   */
  uint32_t version;
  /**
   * Maximum size of the filter bytecodes in byte for an iface.
   */
  uint32_t maxLength;
};

/**
 * Parameters to specify the Background Scan capabilities of this iface.
 */
struct StaBackgroundScanCapabilities {
  /**
   * Maximum number of byte available for cached scan results
   */
  uint32_t maxCacheSize;
  /**
   * Maximum number of buckets that can be supplied for a scan
   */
  uint32_t maxBuckets;
  /**
   * Maximum number of APs that must be stored for each scan.
   */
  uint32_t maxApCachePerScan;
  /**
   * Max reporting number of scans threshold that can be specified in the scan
   * parameters.
   */
  int32_t maxReportingThreshold;
};

/**
 * Bands that can be specified in Background scan requests.
 */
enum StaBackgroundScanBand : uint32_t {
  BAND_UNSPECIFIED,
  /**
   * 2.4 GHz.
   */
  BAND_24GHZ = 1,
  /**
   * 5 GHz without DFS.
   */
  BAND_5GHZ = 2,
  /**
   * 5 GHz DFS only.
   */
  BAND_5GHZ_DFS = 4,
  /**
   * 5 GHz with DFS.
   */
  BAND_5GHZ_WITH_DFS = 6,
  /**
   * 2.4 GHz + 5 GHz; no DFS.
   */
  BAND_24GHZ_5GHZ = 3,
  /**
   * 2.4 GHz + 5 GHz with DFS
   */
  BAND_24GHZ_5GHZ_WITH_DFS = 7
};

/**
 * Mask of event reporting schemes that can be specified in background scan
 * requests.
 */
enum StaBackgroundScanBucketEventReportSchemeMask : uint32_t {
  /**
   * Report a scan completion event after scan. If this is not set then scan
   * completion events must be reported if report_threshold_percent or
   * report_threshold_num_scans is reached.
   */
  EACH_SCAN = 1 << 0,
  /**
   * Forward scan results (beacons/probe responses + IEs) in real time to HAL,
   * in addition to completion events.
   * Note: To keep backward compatibility, fire completion events regardless
   * of REPORT_EVENTS_EACH_SCAN.
   */
  FULL_RESULTS = 1 << 1,
  /**
   * Controls if scans for this bucket must be placed in the results buffer.
   */
  NO_BATCH = 1 << 2,
};

/**
 * Background Scan parameters per bucket that can be specified in background
 * scan requests.
 */
struct StaBackgroundScanBucketParameters {
  /**
   * Bands to scan or 0 if frequencies list must be used instead.
   */
  StaBackgroundScanBand band;
  /**
   * Channel frequencies (in Mhz) to scan if |band| is set to
   * |UNSPECIFIED|.
   */
  vec<WifiChannelInMhz> frequencies;
  /**
   * Period at which this bucket must be scanned (in milliseconds). Must be an integer
   * multiple of the |basePeriodInMs| specified in the BackgroundScanParameters.
   */
  uint32_t periodInMs;
  /**
   * Bitset of |BackgroundScanBucketEventReportSchemeMask| values controlling
   * when events for this bucket must be reported.
   */
  uint32_t eventReportScheme;
  /**
   * For exponential back off. If |exponentialMaxPeriodInMs| is non zero or
   * different than period, then this bucket is an exponential backoff bucket
   * and the scan period must grow exponentially as per formula:
   *   actual_period(N) = period * (base ^ (N/step_count))
   * to this maximum period (in milliseconds).
   */
  uint32_t exponentialMaxPeriodInMs;
  /**
   * For exponential back off. multiplier: new_period=old_period * base
   */
  uint32_t exponentialBase;
  /**
   * For exponential back off. Number of scans to perform for a given
   * period.
   */
  uint32_t exponentialStepCount;
};

/**
 * Background Scan parameters that can be specified in background scan
 * requests.
 */
struct StaBackgroundScanParameters {
  /**
   * GCD of all bucket periods (in milliseconds).
   */
  uint32_t basePeriodInMs;
  /**
   * Maximum number of APs that must be stored for each scan. If the maximum
   * is reached the highest RSSI results must be returned.
   */
  uint32_t maxApPerScan;
  /**
   * % cache buffer filled threshold at which the host must be notified of
   * batched scan results.
   */
  uint32_t reportThresholdPercent;
  /**
   * Threshold at which the AP must be woken up, in number of scans.
   */
  uint32_t reportThresholdNumScans;
  /**
   * List of buckets to be scheduled.
   */
  vec<StaBackgroundScanBucketParameters> buckets;
};

/**
 * Packet stats for different traffic categories.
 */
struct StaLinkLayerIfacePacketStats {
  /**
   * Number of received unicast data packets.
   */
  uint64_t rxMpdu;
  /**
   * Number of successfully transmitted unicast data pkts (ACK rcvd).
   */
  uint64_t txMpdu;
  /**
   * Number of transmitted unicast data pkt losses (no ACK).
   */
  uint64_t lostMpdu;
  /**
   * Number of transmitted unicast data retry pkts.
   */
  uint64_t retries;
};

/**
 * Iface statistics for the current connection.
 */
struct StaLinkLayerIfaceStats {
  /**
   * Number beacons received from the connected AP.
   */
  uint32_t beaconRx;
  /**
   * Access Point Beacon and Management frames RSSI (averaged).
   */
  int32_t avgRssiMgmt;
  /**
   * WME Best Effort Access Category packet counters.
   */
  StaLinkLayerIfacePacketStats wmeBePktStats;
  /**
   * WME Background Access Category packet counters.
   */
  StaLinkLayerIfacePacketStats wmeBkPktStats;
  /**
   * WME Video Access Category packet counters.
   */
  StaLinkLayerIfacePacketStats wmeViPktStats;
  /**
   * WME Voice Access Category packet counters.
   */
  StaLinkLayerIfacePacketStats wmeVoPktStats;
};

/**
 * Cumulative radio statistics since collection was enabled.
 */
struct StaLinkLayerRadioStats {
  /**
   * Time for which the radio is awake.
   */
  uint32_t onTimeInMs;
  /**
   * Total time for which the radio is in active transmission.
   */
  uint32_t txTimeInMs;
  /**
   * Time for which the radio is in active tranmission per tx level.
   */
  vec<uint32_t> txTimeInMsPerLevel;
  /**
   * Time for which the radio is in active receive.
   */
  uint32_t rxTimeInMs;
  /**
   *  Total time for which the radio is awake due to scan.
   */
  uint32_t onTimeInMsForScan;
};

/**
 * Link layer stats retrieved via |getLinkLayerStats|.
 */
struct StaLinkLayerStats {
  StaLinkLayerIfaceStats iface;
  StaLinkLayerRadioStats radio;
  /**
   * TimeStamp for each stats sample.
   * This is the absolute milliseconds from boot when these stats were
   * sampled.
   */
  TimeStampInMs timeStampInMs;
};

/**
 * Structure describing all the information about a single access point seen
 * during the scan.
 */
struct StaScanResult {
  TimeStampInUs timeStampInUs;
  vec<uint8_t> ssid;
  Bssid bssid;
  Rssi rssi;
  WifiChannelInMhz frequency;
  uint16_t beaconPeriodInMs;
  uint16_t capability;
  vec<WifiInformationElement> informationElements;
};

/**
 * Mask of flags set in the |ScanData| instance.
 */
enum StaScanDataFlagMask : int32_t {
  /**
   * Indicates that a scan was interrupted/did not occur so results may be
   * incomplete.
   */
  INTERRUPTED = 1 << 0,
};

/**
 * Structure describing all the information about all the access points seen during
 * the scan.
 */
struct StaScanData {
  /**
   * Bitset containing |ScanDataFlagMask| values.
   */
  uint32_t flags;
  /**
   * Bitset where each bit indicates if the bucket with that index was
   * scanned.
   */
  uint32_t bucketsScanned;
  /**
   * List of scan results.
   */
  vec<StaScanResult> results;
};

/**
 * Structure describing the roaming control capabilities supported.
 */
struct StaRoamingCapabilities {
  /**
   * Maximum number of BSSID's that may be blacklisted.
   */
  uint32_t maxBlacklistSize;
  /**
   * Maximum number of SSID's that may be whitelisted.
   */
  uint32_t maxWhitelistSize;
};

/**
 * Structure describing the roaming control configuration.
 */
struct StaRoamingConfig {
  /**
   * List of BSSID's that are blacklisted for roaming.
   */
  vec<Bssid> bssidBlacklist;
  /**
   * List of SSID's that are whitelisted for roaming.
   */
  vec<Ssid> ssidWhitelist;
};

/**
 * Enum describing the various states to set the roaming
 * control to.
 */
enum StaRoamingState : uint8_t {
  /**
   * Driver/Firmware is allowed to perform roaming respecting
   * the |StaRoamingConfig| parameters set using |configureRoaming|.
   */
  ENABLED = 0,
  /**
   * Driver/Firmware must not perform any roaming.
   */
  DISABLED = 1
};

/**
 * NAN specific types.
 * TODO(b/32159498): Move to a separate nan_types.hal.
 */
/**
 * Various max sizes used in the NAN interface.
 */
enum NanMaxSize : uint32_t {
  SOCIAL_CHANNELS = 3,
  SERVICE_NAME_LEN = 255,
  MATCH_FILTER_LEN = 255,
  SERVICE_SPECIFIC_INFO_LEN = 1024,
  VSA_DATA_LEN = 1024,
  MESH_DATA_LEN = 32,
  INFRA_DATA_LEN = 32,
  CLUSTER_ATTRIBUTE_LEN = 255,
  SUBSCRIBE_MAX_ADDRESS = 42,
  FAM_CHANNELS = 32,
  POSTDISCOVERY_LEN = 5,
  FRAME_DATA_LEN = 504,
  DP_APP_INFO_LEN = 512,
};

/**
 * NAN protocol Version info.
 */
typedef int32_t NanVersion;

/**
 * NAN data path identifiers.
 */
typedef uint32_t NanDataPathId;

/**
 * Data request Initiator/Responder app/service related info.
 */
struct NanDataPathAppInfo {
  /**
   * Max length: |MAX_DP_APP_INFO_LEN|.
   */
  vec<uint8_t> ndpAppInfo;
};

/**
 * Configuration params of Data request Initiator/Responder.
 */
struct NanDataPathCfg {
  /**
   * Indicates whether to use Security/No Security.
   */
  bool useSecurity;
  /**
   * Indicating whether to use QOS/No QOS.
   */
  bool useQos;
};

/**
 * Indicates the availability interval duration associated with the
 * Availability Intervals Bitmap field
 */
enum NanAvailDuration : uint32_t {
  DURATION_16MS = 0,
  DURATION_32MS = 1,
  DURATION_64MS = 2,
};

/**
 * Possible connection types in Post NAN Discovery attributes.
 */
enum NanConnectionType : uint32_t {
  WLAN_INFRA = 0,
  P2P_OPER = 1,
  WLAN_IBSS = 2,
  WLAN_MESH = 3,
  FURTHER_SERVICE_AVAILABILITY = 4,
  WLAN_RANGING = 5,
};

/**
 * Possible device roles in Post NAN Discovery attributes.
 */
enum NanDeviceRole : uint32_t {
  WLAN_INFRA_AP = 0,
  WLAN_INFRA_STA = 1,
  P2P_OPER_GO = 2,
  P2P_OPER_DEV = 3,
  P2P_OPER_CLI = 4,
};

/**
 * Data request Responder's response.
 */
enum NanDataPathResponseCode : uint32_t {
  ACCEPT = 0,
  REJECT,
};

/**
 * Further availability per channel information.
 */
struct NanFurtherAvailabilityChannel {
  /**
   * Defined above.
   */
  NanAvailDuration entryControl;
  /**
   * 1 byte field indicating the frequency band the NAN Device
   * must be available as defined in IEEE Std. 802.11-2012
   * Annex E Table E-4 Global Operating Classes
   */
  uint8_t classVal;
  /**
   * 1 byte field indicating the channel the NAN Device
   * must be available.
   */
  uint8_t channel;
  /**
   * Map Id - 4 bit field which identifies the Further
   * availability map attribute.
   */
  uint8_t mapid;
  /**
   * Divides the time between the beginnings of consecutive "Discovery
   * Windows" of a given NAN cluster into consecutive time intervals
   * of equal durations. The time interval duration is specified by
   * the |entryControl| field.
   * A  device that sets the i-th bit of the Availability
   * Intervals Bitmap to 1 shall be present during the corresponding
   * i-th time interval in the operation channel indicated by the
   * Operating Class and Channel Number fields in the same Availability Entry.
   * A  device that sets the i-th bit of the Availability Intervals Bitmap to
   * 0 may be present during the corresponding i-th time interval in the operation
   * channel indicated by the Operating Class and Channel Number fields in the same
   * Availability Entry.
   * The size of the Bitmap is dependent upon the Availability Interval Duration
   * Chosen in the Entry Control Field.  The size can be either 1, 2 or 4 bytes long
   * - Duration field is equal to 0, only AIB[0] is valid
   * - Duration field is equal to 1, only AIB [0] and AIB [1] is valid
   * - Duration field is equal to 2, AIB [0], AIB [1], AIB [2] and AIB [3] are valid
   */
  uint32_t availIntervalBitmap;
};

/**
 * NAN Publish Types.
 */
enum NanPublishType : uint32_t {
  UNSOLICITED = 0,
  SOLICITED,
  UNSOLICITED_SOLICITED,
};

/**
 * NAN Transmit Priorities.
 */
enum NanTxPriority : uint32_t {
  NORMAL = 0,
  HIGH,
};

/**
 * NAN Transmit Types.
 */
enum NanTxType : uint32_t {
  BROADCAST = 0,
  UNICAST,
};

/**
 * NAN Subscribe Type.
 */
enum NanSubscribeType : uint32_t {
  PASSIVE = 0,
  ACTIVE,
};

/**
 * NAN Service Response Filter Attribute Bit.
 */
enum NanSrfType : uint32_t {
  BLOOM_FILTER = 0,
  PARTIAL_MAC_ADDR,
};

/**
 * NAN Service Response Filter Include Bit.
 */
enum NanSrfIncludeType : uint32_t {
  DO_NOT_RESPOND = 0,
  RESPOND,
};

/**
 * NAN Match indication type.
 */
enum NanMatchAlg : uint32_t {
  MATCH_ONCE = 0,
  MATCH_CONTINUOUS,
  MATCH_NEVER,
};

/**
 * NAN Transmit Window Type.
 */
enum NanTransmitWindowType : uint32_t {
  DW = 0,
  FAW,
};

/**
 * NAN DP channel config options.
 */
enum NanDataPathChannelCfg : uint32_t {
  CHANNEL_NOT_REQUESTED = 0,
  REQUEST_CHANNEL_SETUP,
  FORCE_CHANNEL_SETUP,
};

/**
 * Host can send Vendor specific attributes which the Discovery Engine can
 * enclose in Beacons and/or Service Discovery frames transmitted.
 * Below structure is used to populate that.
 * TODO(b/32207606): This can be moved to vendor extension.
 */
struct NanTransmitVendorSpecificAttribute {
  /**
   * 0 = transmit only in the next discovery window
   * 1 = transmit in next 16 discovery window
   */
  uint8_t payloadTransmitFlag;
  /**
   * Below flags must determine in which all frames
   * the vendor specific attributes must be included
   */
  uint8_t txInDiscoveryBeacon;
  uint8_t txInSyncBeacon;
  uint8_t txInServiceDiscovery;
  /**
   * Organizationally Unique Identifier.
   */
  uint32_t vendorOui;
  /**
   * Vendor specific attribute to be transmitted.
   * Max length: |MAX_VSA_DATA_LEN|.
   */
  vec<uint8_t> vsa;
};

/**
 * Host can set the Periodic scan parameters for each of the
 * 3(6, 44, 149) Social channels. Only these channels are allowed
 * any other channels are rejected
 */
 enum NanChannelIndex : uint32_t {
  CHANNEL_24G_BAND = 0,
  CHANNEL_5G_BAND_LOW,
  CHANNEL_5G_BAND_HIGH,
};

/**
 * Structure to set the Social Channel Scan parameters
 * passed as part of EnableRequest/ConfigRequest.
 */
struct NanSocialChannelScanParams {
  /**
   * Dwell time of each social channel in milliseconds
   * ChannelIndex corresponds to the respective channel
   * If time set to 0 then the FW default time must be used.
   * Max length: |MAX_SOCIAL_CHANNELS|.
   * dwellTime[i] refers to the dwell time of the i'th social channel.
   */
  vec<uint8_t> dwellTime;
  /**
   * Scan period of each social channel in seconds
   * ChannelIndex corresponds to the respective channel
   * If time set to 0 then the FW default time must be used.
   * Max length: |MAX_SOCIAL_CHANNELS|.
   * scanPeriod[i] refers to the scan period of the i'th social channel.
   */
  vec<uint16_t> scanPeriod;
};

/**
 * Enable Request Message Structure
 * The EnableReq message in  structs the Discovery Engine to enter an operational state
 */
struct NanEnableRequest {
  /**
   * Mandatory parameters below.
   */
  uint8_t masterPref;
  /**
   * A cluster_low value matching cluster_high indicates a request to join
   * a cluster with that value. If the requested cluster is not found the
   * device must start its own cluster.
   */
  uint16_t clusterLow;
  uint16_t clusterHigh;
  /**
   * Optional configuration of Enable request.
   * Each of the optional parameters have configure flag which
   * determine whether configuration is to be passed or not.
   */
  bool validSupport5gVal;
  uint8_t support5gVal;
  /**
   * BIT 0 is used to specify to include Service IDs in Sync/Discovery beacons
   * 0 - Do not include SIDs in any beacons
   * 1 - Include SIDs in all beacons.
   * Rest 7 bits are count field which allows control over the number of SIDs
   * included in the Beacon.  0 means to include as many SIDs that fit into
   * the maximum allow Beacon frame size
   */
  bool validSidBeaconVal;
  uint8_t sidBeaconVal;
  /**
   * The rssi values below must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  bool valid2dot4gRssiCloseVal;
  uint8_t rssiClose2dot4gVal;
  bool valid2dot4gRssiMiddleVal;
  uint8_t rssiMiddle2dot4gVal;
  bool valid2dot4gRssiProximityVal;
  uint8_t rssiProximity2dot4gVal;
  bool validHopCountLimitVal;
  uint8_t hopCountLimitVal;
  /**
   * Defines 2.4G channel access support
   */
  bool valid2dot4gSupportVal;
  bool support2dot4gVal;
  /**
   * Defines 2.4G channels must be used for sync/discovery beacons
   */
  bool valid2dot4gBeaconsVal;
  bool beacon2dot4gVal;
  /**
   * Defines 2.4G channels must be used for Service Discovery frames
   */
  bool valid2dot4gSdfVal;
  bool sdf2dot4gVal;
  /**
   * Defines 5G channels must be used for sync/discovery beacons
   */
  bool valid5gBeaconsVal;
  bool beacon5gVal;
  /**
   * Defines 5G channels must be used for Service Discovery frames
   */
  bool valid5gSdfVal;
  bool sdf5gVal;
  /**
   * 1 byte value which defines the RSSI in
   * dBm for a close by Peer in 5 Ghz channels.
   * The rssi values must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  bool valid5gRssiCloseVal;
  uint8_t rssiClose5gVal;
  /**
   * 1 byte value which defines the RSSI value in
   * dBm for a close by Peer in 5 Ghz channels.
   * The rssi values must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  bool valid5gRssiMiddleVal;
  uint8_t rssiMiddle5gVal;
  /**
   * 1 byte value which defines the RSSI filter
   * threshold.  Any Service Descriptors received above this
   * value that are configured for RSSI filtering must be dropped.
   * The rssi values must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  bool valid5gRssiCloseProximityVal;
  uint8_t rssiCloseProximity5gVal;
  /**
   * 1 byte quantity which defines the window size over
   * which the “average RSSI” must be calculated over.
   */
  bool validRssiWindowSizeVal;
  uint8_t rssiWindowSizeVal;
  /**
   * The 24 bit Organizationally Unique ID + the 8 bit Network Id.
   */
  uint8_t validOuiVal;
  uint32_t ouiVal;
  /**
   * NAN Interface Address, If not configured the Discovery Engine
   * must generate a 6 byte Random MAC.
   */
  bool validIntfAddrVal;
  MacAddress intfAddrVal;
  /**
   * If set to true, the Discovery Engine must enclose the Cluster
   * Attribute only sent in Beacons in a Vendor Specific Attribute
   * and transmit in a Service Descriptor Frame.
   */
  bool configClusterAttributeVal;
  /**
   * The periodicity in seconds between full scan’s to find any new
   * clusters available in the area. A Full scan must not be done
   * more than every 10 seconds and must not be done less than every
   * 30 seconds.
   */
  bool validScanParamsVal;
  NanSocialChannelScanParams scanParamsVal;
  /**
   * 1 byte quantity which forces the Random Factor to a particular
   * value for all transmitted Sync/Discovery beacons
   */
  bool validRandomFactorForceVal;
  uint8_t randomFactorForceVal;
  /**
   * 1 byte quantity which forces the HC for all transmitted Sync and
   * Discovery Beacon NO matter the real HC being received over the
   * air.
   */
  bool validHopCountForceVal;
  uint8_t hopCountForceVal;
  /**
   * Channel frequency in MHz to enable  on.
   */
  bool valid24gChannelVal;
  WifiChannelInMhz channel24gVal;
  bool valid5gChannelVal;
  WifiChannelInMhz channel5gVal;
};


/**
 * Publish Msg Structure
 * Message is used to request the DE to publish the Service Name
 * using the parameters passed into the "Discovery Window".
 */
struct NanPublishRequest {
  /**
   * Id  0 means new publish, any other id is existing publish.
   */
  uint16_t publishId;
  /**
   * How many seconds to run for. 0 means forever until canceled.
   */
  uint16_t ttl;
  /**
   * Periodicity of OTA unsolicited publish. Specified in increments of 500 ms.
   */
  uint16_t period;
  /**
   * 0= unsolicited, solicited = 1, 2= both.
   */
  NanPublishType publishType;
  /**
   * 0 = broadcast, 1= unicast  if solicited publish.
   */
  NanTxType txType;
  /**
   * Number of OTA Publish, 0 means forever until canceled.
   */
  uint8_t publishCount;
  /**
   * UTF-8 encoded string identifying the service.
   * Max length: |MAX_SERVICE_NAME_LEN|.
   */
  string serviceName;
  /**
   * Field which specifies how the matching indication to host is controlled.
   * 0 - Match and Indicate Once
   * 1 - Match and Indicate continuous
   * 2 - Match and Indicate never. This means don't indicate the match to
   *     the host.
   * 3 - Reserved
   */
  NanMatchAlg publishMatchIndicator;
  /**
   * Sequence of values NAN Device that has invoked a Subscribe method
   * corresponding to this Publish method.
   * Max length: |MAX_SERVICE_SPECIFIC_INFO_LEN|.
   */
  vec<uint8_t> serviceSpecificInfo;
  /**
   * Ordered sequence of <length, value> pairs which specify further response conditions
   * beyond the service name used to filter subscribe messages to respond to.
   * This is only needed when the PT is set to SOLICITED or SOLICITED_UNSOLICITED.
   * Max length: |MAX_MATCH_FILTER_LEN|.
   */
  vec<uint8_t> rxMatchFilter;
  /**
   * Ordered sequence of <length, value> pairs to be included in the Discovery Frame.
   * If present it is always sent in a Discovery Frame
   * Max length: |MAX_MATCH_FILTER_LEN|.
   */
  vec<uint8_t> txMatchFilter;
  /**
   * Flag which specifies that the Publish must use the configured RSSI
   * threshold and the received RSSI in order to filter requests
   * false – ignore the configured RSSI threshold when running a Service
   * Descriptor attribute or Service ID List Attribute through the DE matching logic.
   * true – use the configured RSSI threshold when running a Service
   * Descriptor attribute or Service ID List Attribute through the DE matching logic.
   */
  bool useRssiThreshold;
  /**
   * 8-bit bitmap which allows the Host to associate this publish
   * with a particular Post-NAN Connectivity attribute
   * which has been sent down in a ConfigureRequest/EnableRequest
   * message.  If the DE fails to find a configured Post-NAN
   * connectivity attributes referenced by the bitmap,
   * the DE must return an error code to the Host.
   * If the Publish is configured to use a Post-NAN Connectivity
   * attribute and the Host does not refresh the Post-NAN Connectivity
   * attribute the Publish must be canceled and the Host must be sent
   * a PublishTerminatedIndication message.
   */
  uint8_t connmap;
  /**
   * Set/Enable corresponding bits to disable any indications that follow a publish.
   * BIT0 - Disable publish termination indication.
   * BIT1 - Disable match expired indication.
   * BIT2 - Disable followUp indication received (OTA).
   */
  uint8_t recvIndicationCfg;
};

/**
 * Publish Cancel Msg Structure.
 * The PublishServiceCancelReq Message is used to request the DE to stop publishing
 * the Service Name identified by the Publish Id in the message.
 */
struct NanPublishCancelRequest {
  uint16_t publishId;
};

/**
 * NAN Subscribe Structure.
 * The SubscribeServiceReq message is sent to the Discovery Engine
 * whenever the Upper layers would like to listen for a Service Name
 */
struct NanSubscribeRequest {
  /**
   * Id 0 means new subscribe, non zero is existing subscribe.
   */
  uint16_t subscribeId;
  /**
   * How many seconds to run for. 0 means forever until canceled.
   */
  uint16_t ttl;
  /**
   * Periodicity of OTA Active Subscribe. Units in increments of 500 ms,
   * 0 = attempt every DW.
   */
  uint16_t period;
  /**
   * Flag which specifies how the Subscribe request shall be processed.
   * 0 - PASSIVE , 1- ACTIVE.
   */
  NanSubscribeType subscribeType;
  /**
   * Flag which specifies on Active Subscribes how the Service Response Filter
   * attribute is populated.
   * 0 - Bloom Filter, 1 - MAC Addr.
   */
  NanSrfType serviceResponseFilter;
  /**
   * Flag which specifies how the Service Response Filter Include bit is
   * populated.
   * 0=Do not respond if in the Address Set, 1= Respond.
   */
  NanSrfIncludeType serviceResponseInclude;
  /**
   * Flag which specifies if the Service Response Filter must be used when
   * creating Subscribes.
   * 0=Do not send the Service Response Filter,1= send.
   */
  bool shouldUseServiceResponseFilter;
  /**
   * Flag which specifies if the Service Specific Info is needed in
   * the Publish message before creating the MatchIndication.
   * 0=Not needed, 1= Required.
   */
  bool isSsiRequiredForMatchIndication;
  /**
   * Field which specifies how the matching indication to host is controlled.
   * 0 - Match and Indicate Once
   * 1 - Match and Indicate continuous
   * 2 - Match and Indicate never. This means don't indicate the match to the
   *     host.
   * 3 - Reserved
   */
  NanMatchAlg subscribeMatchIndicator;
  /**
   * The number of Subscribe Matches which must occur
   * before the Subscribe request is automatically terminated.
   * If this value is 0 this field is not used by the DE.
   */
  uint8_t subscribeCount;
  /**
   * UTF-8 encoded string identifying the service.
   * Max length: |MAX_SERVICE_NAME_LEN|.
   */
  string serviceName;
  /**
   * Sequence of values which further specify the published service beyond the
   * service name.
   * Max length: |MAX_SERVICE_SPECIFIC_INFO_LEN|.
   */
  vec<uint8_t> serviceSpecificInfo;
  /**
   * Ordered sequence of <length, value> pairs used to filter out received
   * publish discovery messages.
   * This can be sent both for a Passive or an Active Subscribe
   * Max length: |MAX_MATCH_FILTER_LEN|.
   */
  vec<uint8_t> rxMatchFilter;
  /**
   * Ordered sequence of <length, value> pairs  included in the
   * Discovery Frame when an Active Subscribe is used.
   * Max length: |MAX_MATCH_FILTER_LEN|.
   */
  vec<uint8_t> txMatchFilter;
  /**
   * Flag which specifies that the Publish must use the configured RSSI
   * threshold and the received RSSI in order to filter requests
   * false – ignore the configured RSSI threshold when running a Service
   * Descriptor attribute or Service ID List Attribute through the DE matching logic.
   * true – use the configured RSSI threshold when running a Service
   * Descriptor attribute or Service ID List Attribute through the DE matching logic.
   */
  bool useRssiThreshold;
  /**
   * 8-bit bitmap which allows the Host to associate this Active
   * Subscribe with a particular Post-NAN Connectivity attribute
   * which has been sent down in a ConfigureRequest/EnableRequest
   * message.  If the DE fails to find a configured Post-NAN
   * connectivity attributes referenced by the bitmap,
   * the DE must return an error code to the Host.
   * If the Subscribe is configured to use a Post-NAN Connectivity
   * attribute and the Host does not refresh the Post-NAN Connectivity
   * attribute the Subscribe must be canceled and the Host must be sent
   * a SubscribeTerminatedIndication message.
   */
  uint8_t connmap;
  /**
   * NAN Interface Address, conforming to the format as described in
   * 8.2.4.3.2 of IEEE Std. 802.11-2012.
   * Max length: |MAX_SUBSCRIBE_MAX_ADDRESS|.
   */
  vec<MacAddress> intfAddr;
  /**
   * Set/Enable corresponding bits to disable indications that follow a
   * subscribe.
   * BIT0 - Disable subscribe termination indication.
   * BIT1 - Disable match expired indication.
   * BIT2 - Disable followUp indication received (OTA).
   */
  uint8_t recvIndicationCfg;
};

/**
 * NAN Subscribe Cancel Structure
 * The SubscribeCancelReq Message is used to request the DE to stop looking
 * for the Service Name.
 */
struct NanSubscribeCancelRequest {
  uint16_t subscribeId;
};

/**
 * Transmit follow up Structure.
 * The TransmitFollowupReq message is sent to the DE to allow the sending of
 * the Service_Specific_Info to a particular MAC address.
 */
struct NanTransmitFollowupRequest {
  /**
   * Publish or Subscribe Id of an earlier Publish/Subscribe.
   */
  uint16_t publishSubscribeId;
  /**
   * This Id is the Requestor Instance that is passed as
   * part of earlier MatchInd/FollowupInd message.
   */
  uint32_t requestorInstanceId;
  /**
   * Unicast address.
   */
  MacAddress addr;
  /**
   * Priority of the request 2=high.
   */
  NanTxPriority priority;
  /**
   * Flag which the DE uses to decide if received in a DW or a FAW
   * 0= send in a DW, 1=send in FAW.
   */
  NanTransmitWindowType dwOrFaw;
  /**
   * Sequence of values which further specify the published service beyond
   * the service name.
   * Max length: |MAX_SERVICE_SPECIFIC_INFO_LEN|.
   */
  vec<uint8_t> serviceSpecificInfo;
  /**
   * Set/Enable corresponding bits to disable responses after followUp.
   * BIT0 - Disable followUp response from FW.
   */
  uint8_t recvIndicationCfg;
};

/**
 * Config Structure.
 * The ConfigurationReq message is sent by the Host to the
 * Discovery Engine in order to configure the Discovery Engine during runtime.
 */
struct NanConfigRequest {
  bool validSidBeaconVal;
  uint8_t sidBeacon;
  bool validRssiProximityVal;
  uint8_t rssiProximity;
  bool validMasterPrefVal;
  uint8_t masterPref;
  /**
   * 1 byte value which defines the RSSI filter threshold.
   * Any Service Descriptors received above this value
   * that are configured for RSSI filtering must be dropped.
   * The rssi values must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  bool valid5gRssiCloseProximityVal;
  uint8_t rssiCloseProximity5gVal;
  /**
   * 2 byte quantity which defines the window size over
   * which the “average RSSI” must be calculated over.
   */
  bool validRssiWindowSizeVal;
  uint16_t rssiWindowSizeVal;
  /**
   * If set to 1, the Discovery Engine must enclose the Cluster
   * Attribute only sent in Beacons in a Vendor Specific Attribute
   * and transmit in a Service Descriptor Frame.
   */
  bool configClusterAttributeVal;
  /**
   * The periodicity in seconds between full scan’s to find any new
   * clusters available in the area.  A Full scan must not be done
   * more than every 10 seconds and must not be done less than every
   * 30 seconds.
   */
  bool validScanParamsVal;
  NanSocialChannelScanParams scanParamsVal;
  /**
   * 1 byte quantity which forces the Random Factor to a particular
   * value for all transmitted Sync/Discovery beacons
   */
  bool validRandomFactorForceVal;
  uint8_t randomFactorForceVal;
  /**
   * 1 byte quantity which forces the HC for all transmitted Sync and
   * Discovery Beacon NO matter the real HC being received over the
   * air.
   */
  bool validHopCountForceVal;
  uint8_t hopCountForceVal;
};

/**
 * Beacon Sdf Payload Structure
 * The Discovery Engine can be configured to publish vendor specific attributes as part of
 * beacon or service discovery frame transmitted as part of this request..
 */
struct NanBeaconSdfPayloadRequest {
  /**
   * VendorAttribute must have the Vendor Specific Attribute which the
   * vendor wants to publish as part of Discovery or Sync or Service discovery frame
   */
  NanTransmitVendorSpecificAttribute vsa;
};

/**
 *  Data Path Initiator requesting a data session.
 */
struct NanDataPathInitiatorRequest {
  /**
   * Unique Instance Id identifying the Responder's service.
   * This is same as publish_id notified on the subscribe side
   * in a publish/subscribe scenario
   */
  uint32_t serviceInstanceId;
  /**
   * Config flag for channel request.
   */
  NanDataPathChannelCfg channelRequestType;
  /**
   * Channel frequency in MHz to start data-path.
   */
  WifiChannelInMhz channel;
  /**
   * Discovery MAC addr of the publisher/peer.
   */
  MacAddress peerDiscMacAddr;
  /**
   * Interface name on which this NDP session is to be started.
   * This must be the same interface name provided during interface
   * create.
   */
  string ndpIface;
  /**
   * Initiator/Responder Security/QoS configuration.
   */
  NanDataPathCfg ndpCfg;
  /**
   * App/Service information of the Initiator.
   */
  NanDataPathAppInfo appInfo;
};

/**
 * Data struct Nanto initiate a data response on the responder side
 * for an indication received with a data request.
 */
struct NanDataPathIndicationResponse {
  /**
   * Unique token Id generated on the initiator/responder
   * side used for a NDP session between two NAN devices.
   */
  NanDataPathId ndpInstanceId;
  /**
   * Interface name on which this NDP session is to be started.
   * This must be the same interface name provided during interface
   * create.
   */
  string ndpIface;
  /**
   * Initiator/Responder Security/QoS configuration.
   */
  NanDataPathCfg ndpCfg;
  /**
   * App/Service information of the responder.
   */
  NanDataPathAppInfo appInfo;
  /**
   * Response Code indicating ACCEPT/REJECT/DEFER
   */
  NanDataPathResponseCode rspCode;
};

/**
 * NDP termination info.
 */
struct NanDataPathEndRequest {
  uint8_t numNdpInstances;
  /**
   * Unique token Id generated on the initiator/responder side
   * used for a NDP session between two NAN devices
   */
  vec<NanDataPathId> ndpInstanceIds;
};

/**
 * Definition of various ResponseType
 */
enum NanResponseType : uint32_t  {
  ENABLED = 0,
  DISABLED = 1,
  PUBLISH = 2,
  PUBLISH_CANCEL = 3,
  TRANSMIT_FOLLOWUP = 4,
  SUBSCRIBE = 5,
  SUBSCRIBE_CANCEL = 6,
  CONFIG = 8,
  ERROR = 10,
  BEACON_SDF_PAYLOAD = 11,
  GET_CAPABILITIES = 12,
  DP_INTERFACE_CREATE = 13,
  DP_INTERFACE_DELETE = 14,
  DP_INITIATOR_RESPONSE = 15,
  DP_RESPONDER_RESPONSE = 16,
  DP_END = 17,
};

/**
 * Various NAN Protocol Response code
 */
enum NanStatusType : uint32_t {
  /* NAN Protocol Response Codes */
  SUCCESS = 0,
  TIMEOUT = 1,
  DE_FAILURE = 2,
  INVALID_MSG_VERSION = 3,
  INVALID_MSG_LEN = 4,
  INVALID_MSG_ID = 5,
  INVALID_HANDLE = 6,
  NO_SPACE_AVAILABLE = 7,
  INVALID_PUBLISH_TYPE = 8,
  INVALID_TX_TYPE = 9,
  INVALID_MATCH_ALGORITHM = 10,
  DISABLE_IN_PROGRESS = 11,
  INVALID_TLV_LEN = 12,
  INVALID_TLV_TYPE = 13,
  MISSING_TLV_TYPE = 14,
  INVALID_TOTAL_TLVS_LEN = 15,
  INVALID_MATCH_HANDLE = 16,
  INVALID_TLV_VALUE = 17,
  INVALID_TX_PRIORITY = 18,
  INVALID_CONNECTION_MAP = 19,
  NOT_ALLOWED = 22,
  NO_OTA_ACK = 23,
  TX_FAIL = 24,
  ALREADY_ENABLED = 25,
  FOLLOWUP_QUEUE_FULL = 26,

  /* NAN Configuration Response codes */
  INVALID_RSSI_CLOSE_VALUE = 4096,
  INVALID_RSSI_MIDDLE_VALUE = 4097,
  INVALID_HOP_COUNT_LIMIT = 4098,
  INVALID_MASTER_PREFERENCE_VALUE = 4099,
  INVALID_LOW_CLUSTER_ID_VALUE = 4100,
  INVALID_HIGH_CLUSTER_ID_VALUE = 4101,
  INVALID_BACKGROUND_SCAN_PERIOD = 4102,
  INVALID_RSSI_PROXIMITY_VALUE = 4103,
  INVALID_SCAN_CHANNEL = 4104,
  INVALID_POST_CONNECTIVITY_CAPABILITIES_BITMAP = 4105,
  INVALID_FURTHER_AVAILABILITY_MAP_NUMCHAN_VALUE = 4106,
  INVALID_FURTHER_AVAILABILITY_MAP_DURATION_VALUE = 4107,
  INVALID_FURTHER_AVAILABILITY_MAP_CLASS_VALUE = 4108,
  INVALID_FURTHER_AVAILABILITY_MAP_CHANNEL_VALUE = 4109,
  INVALID_FURTHER_AVAILABILITY_MAP_AVAILABILITY_INTERVAL_BITMAP_VALUE = 4110,
  INVALID_FURTHER_AVAILABILITY_MAP_MAP_ID = 4111,
  INVALID_POST_DISCOVERY_CONN_TYPE_VALUE = 4112,
  INVALID_POST_DISCOVERY_DEVICE_ROLE_VALUE = 4113,
  INVALID_POST_DISCOVERY_DURATION_VALUE = 4114,
  INVALID_POST_DISCOVERY_BITMAP_VALUE = 4115,
  MISSING_FUTHER_AVAILABILITY_MAP = 4116,
  INVALID_BAND_CONFIG_FLAGS = 4117,
  INVALID_RANDOM_FACTOR_UPDATE_TIME_VALUE = 4118,
  INVALID_ONGOING_SCAN_PERIOD = 4119,
  INVALID_DW_INTERVAL_VALUE = 4120,
  INVALID_DB_INTERVAL_VALUE = 4121,

  /* 4122-8191 RESERVED */
  TERMINATED_REASON_INVALID = 8192,
  TERMINATED_REASON_TIMEOUT = 8193,
  TERMINATED_REASON_USER_REQUEST = 8194,
  TERMINATED_REASON_FAILURE = 8195,
  TERMINATED_REASON_COUNT_REACHED = 8196,
  TERMINATED_REASON_DE_SHUTDOWN = 8197,
  TERMINATED_REASON_DISABLE_IN_PROGRESS = 8198,
  TERMINATED_REASON_POST_DISC_ATTR_EXPIRED = 8199,
  TERMINATED_REASON_POST_DISC_LEN_EXCEEDED = 8200,
  TERMINATED_REASON_FURTHER_AVAIL_MAP_EMPTY = 8201,

  /* 9000-9500 NDP Status type */
  NDP_UNSUPPORTED_CONCURRENCY = 9000,
  NDP_DATA_IFACE_CREATE_FAILED = 9001,
  NDP_DATA_IFACE_DELETE_FAILED = 9002,
  NDP_DATA_INITIATOR_REQUEST_FAILED = 9003,
  NDP_DATA_RESPONDER_REQUEST_FAILED = 9004,
  NDP_INVALID_SERVICE_INSTANCE_ID = 9005,
  NDP_INVALID_NDP_INSTANCE_ID = 9006,
  NDP_INVALID_RESPONSE_CODE = 9007,
  NDP_INVALID_APP_INFO_LEN = 9008,

  /* OTA failures and timeouts during negotiation */
  NDP_MGMT_FRAME_REQUEST_FAILED = 9009,
  NDP_MGMT_FRAME_RESPONSE_FAILED = 9010,
  NDP_MGMT_FRAME_CONFIRM_FAILED = 9011,
  NDP_END_FAILED = 9012,
  NDP_MGMT_FRAME_END_REQUEST_FAILED = 9013,

  /* 9500 onwards vendor specific error codes */
  NDP_VENDOR_SPECIFIC_ERROR = 9500,
};

/**
 * NAN Response message header
 */
struct NanResponseMsgHeader {
  /**
   * Contains the result code.
   */
  NanStatusType status;
  /**
   * For error returns the value is returned which was in error.
   * TODO(b/32207606): Find all the error values.
   */
  uint32_t value;
  /**
   * ResponseType Definitions.
   */
  NanResponseType responseType;
};

/**
 * Publish Response Message structure.
 */
struct NanPublishResponse {
  uint16_t publishId;
};

/**
 * NAN Publish Response Messages.
 */
struct NanPublishResponseMsg {
  NanResponseMsgHeader header;
  NanPublishResponse body;
};


/**
 * Subscribe Response Message structure.
 */
struct NanSubscribeResponse {
  uint16_t subscribeId;
};

/**
 * NAN Subscribe Response Messages.
 */
struct NanSubscribeResponseMsg {
  NanResponseMsgHeader header;
  NanSubscribeResponse body;
};

/**
 * Response returned for Initiators Data request.
 */
struct NanDataPathResponse {
  /**
   * Unique token Id generated on the initiator
   * side used for a NDP session between two NAN devices
   */
  NanDataPathId ndpInstanceId;
};

/**
 * NAN Data Path Response Messages.
 */
struct NanDataPathResponseMsg {
  NanResponseMsgHeader header;
  NanDataPathResponse body;
};

/**
 * NDP Capabilites response.
 */
struct NanCapabilitiesResponse {
  uint32_t maxConcurrentClusters;
  uint32_t maxPublishes;
  uint32_t maxSubscribes;
  uint32_t maxServiceNameLen;
  uint32_t maxMatchFilterLen;
  uint32_t maxTotalMatchFilterLen;
  uint32_t maxServiceSpecificInfoLen;
  uint32_t maxVsaDataLen;
  uint32_t maxMeshDataLen;
  uint32_t maxNdiInterfaces;
  uint32_t maxNdpSessions;
  uint32_t maxAppInfoLen;
  uint32_t maxQueuedTransmitFollowupMsgs;
};

/**
 * NAN Capabilities Response Messages.
 */
struct NanCapabilitiesResponseMsg {
  NanResponseMsgHeader header;
  NanCapabilitiesResponse body;
};

/**
 * Publish Terminated Message structure.
 * The PublishTerminatedInd message is sent by the DE whenever a Publish
 * terminates from a user-specified timeout or a unrecoverable error in the DE.
 */
struct NanPublishTerminatedInd {
  /**
   * Id returned during the initial Publish.
   */
  uint16_t publishId;
  NanStatusType reason;
};

/**
 * Match Indication Message structure.
 * The MatchInd message is sent once per responding MAC address whenever
 * the Discovery Engine detects a match for a previous SubscribeServiceReq
 * or PublishServiceReq.
 */
struct NanMatchInd {
  /**
   * Publish or Subscribe Id of an earlier Publish/Subscribe.
   */
  uint16_t publishSubscribeId;
  /**
   * A 32 bit Requestor Instance Id which is sent to the Application.
   * This Id must be sent in any subsequent UnmatchInd/FollowupInd
   * messages.
   */
  uint32_t requestorInstanceId;
  MacAddress addr;
  /**
   * Sequence of octets which were received in a Discovery Frame matching the
   * Subscribe Request.
   * Max length: |MAX_SERVICE_SPECIFIC_INFO_LEN|.
   */
  vec<uint8_t> serviceSpecificInfo;
  /**
   * Ordered sequence of <length, value> pairs received in the Discovery Frame
   * matching the Subscribe Request.
   * Max length: |MAX_MATCH_FILTER_LEN|.
   */
  vec<uint8_t> sdfMatchFilter;
  /**
   * Flag to indicate if the Match occurred in a Beacon Frame or in a
   * Service Discovery Frame.
   */
  bool matchOccuredFlag;
  /**
   * Flag to indicate FW is out of resource and that it can no longer
   * track this Service Name. The Host still need to send the received
   * Match_Handle but duplicate MatchInd messages may be received on
   * this Handle until the resource frees up.
   */
  bool outOfResourceFlag;
  /**
   * If RSSI filtering was configured in SubscribeRequest then this
   * field must contain the received RSSI value. 0 if not.
   * All rssi values must be specified without sign.
   * For eg: -70dBm must be specified as 70.
   */
  uint8_t rssiValue;
};

/**
 * MatchExpired Indication Message structure.
 * The MatchExpiredInd message is sent whenever the Discovery Engine detects that
 * a previously Matched Service has been gone for too long. If the previous
 * MatchInd message for this Publish/Subscribe Id had the out_of_resource_flag
 * set then this message must not be received
 */
struct NanMatchExpiredInd {
  /**
   * Publish or Subscribe Id of an earlier Publish/Subscribe.
   */
  uint16_t publishSubscribeId;
  /**
   * 32 bit value sent by the DE in a previous
   * MatchInd/FollowupInd to the application.
   */
  uint32_t requestorInstanceId;
};

/**
 * Subscribe Terminated Message structure.
 * The SubscribeTerminatedInd message is sent by the DE whenever a
 * Subscribe terminates from a user-specified timeout or a unrecoverable error in the DE.
 */
struct NanSubscribeTerminatedInd {
  /**
   * Id returned during initial Subscribe.
   */
  uint16_t subscribeId;
  NanStatusType reason;
};

/**
 * Followup Indication Message structure.
 * The FollowupInd message is sent by the DE to the Host whenever it receives a
 * Followup message from another peer.
 */
struct NanFollowupInd {
  /**
   * Publish or Subscribe Id of an earlier Publish/Subscribe.
   */
  uint16_t publishSubscribeId;
  /**
   * A 32 bit Requestor instance Id which is sent to the Application.
   * This Id must be used in subsequent UnmatchInd/FollowupInd messages.
   */
  uint32_t requestorInstanceId;
  MacAddress addr;
  /**
   * Flag which the DE uses to decide if received in a DW or a FAW
   * 0= send in a DW, 1=send in FAW.
   */
  NanTransmitWindowType dwOrFaw;
  /**
   * Sequence of values which further specify the published service beyond
   * the service name
   * Max length: |MAX_SERVICE_SPECIFIC_INFO_LEN|.
   */
  vec<uint8_t> serviceSpecificInfo;
};

/**
 * NAN Protocol Event ID Codes.
 */
enum NanDiscEngEventType : uint32_t {
  /**
   * Event data notifying the Mac address of the Discovery engine.
   * which is reported as one of the Discovery engine event
   */
  DISC_MAC_ADDR = 0,
  /**
   * Event data notifying the Cluster address of the cluster
   * which is reported as one of the Discovery engine events.
   */
  STARTED_CLUSTER,
  JOINED_CLUSTER,
};

/**
 * Discovery Engine Event Indication Message structure.
 * The Discovery Engine can inform the Host when significant events occur
 * The data following the EventId is dependent upon the EventId type.
 * In other words, each new event defined must carry a different
 * structure of information back to the host.
 */
struct NanDiscEngEventInd {
  /**
   * NAN Protocol Event Codes.
   */
  NanDiscEngEventType eventType;
  /**
   * Mac Address associated with the corresponding event.
   */
  MacAddress addr;
};

/**
 * NAN Disabled Indication Message structure.
 * The DisableInd message indicates to the upper layers that the Discovery
 * Engine has flushed all state and has been shutdown.  When this message is
 * received the DE is guaranteed to have left the NAN cluster it was part of
 * and must have terminated any in progress Publishes or Subscribes.
 */
struct NanDisabledInd {
  NanStatusType reason;
};

/**
 * Mask to determine on which frames attribute was received.
 */
enum NanVsaRxFrameMask: uint32_t {
  DISCOVERY_BEACON_MASK = 1 << 0,
  SYNC_BEACON_MASK = 1 << 1,
  SERVICE_DISCOVERY_MASK = 1 << 2
};

struct NanReceiveVendorSpecificAttribute {
  /**
   * Frames on which this vendor specific attribute
   * was received. Mask |NanVsaRxFrameMask| defined above.
   */
  uint8_t vsaReceivedOn;
  /**
   * Organizationally Unique Identifier.
   */
  uint32_t vendorOui;
  /**
   * Vendor specific attribute.
   * Max length: |MAX_VSA_DATA_LEN|.
   */
  vec<uint8_t> vsa;
};

/**
 * NAN Beacon SDF Payload Received Message structure.
 * Discovery engine sends the details of received Beacon or
 * Service Discovery Frames as part of this structure.
 */
struct NanBeaconSdfPayloadReceive {
  /**
   * Frame data.
   * Max length: |MAX_FRAME_DATA_LEN|.
   */
  vec<uint8_t> frameData;
};

/**
 * NAN Beacon or SDF Payload Indication Message structure.
 * The BeaconSdfPayloadInd message indicates to the upper layers that information
 * elements were received either in a Beacon or SDF which needs to be delivered
 * outside of a Publish/Subscribe Handle.
 */
struct NanBeaconSdfPayloadInd {
  /**
   * The MAC address of the peer which sent the attributes.
   */
  MacAddress addr;
  /**
   * NAN Receive Vendor Specific Attribute.
   */
  bool isVsaReceived;
  NanReceiveVendorSpecificAttribute vsa;
  /**
   * NAN Beacon or SDF Payload Received.
   */
  bool isBeaconSdfPayloadReceived;
  NanBeaconSdfPayloadReceive data;
};

/**
 * NAN Data path request Indication Message structure.
 * Event indication received on the responder side when a Nan Data request or
 * NDP session is initiated on the Initiator side.
 */
struct NanDataPathRequestInd {
  /**
   * Unique Instance Id corresponding to a service/session.
   * This is similar to the publish_id generated on the
   * publisher side.
   */
  uint16_t serviceInstanceId;
  /**
   * Discovery MAC addr of the peer/initiator.
   */
  MacAddress peerDiscMacAddr;
  /**
   * Unique token Id generated on the initiator/responder side
   * used for a NDP session between two NAN devices.
   */
  NanDataPathId ndpInstanceId;
  /**
   * Initiator/Responder Security/QoS configuration.
   */
  NanDataPathCfg ndpCfg;
  /**
   * App/Service information of the initiator.
   */
  NanDataPathAppInfo appInfo;
};

/**
 * NAN Data path confirmation Indication Message structure.
 * Event indication of data confirm is received on both
 * initiator and responder side confirming a NDP session.
 */
struct NanDataPathConfirmInd {
  /**
   * Unique token Id generated on the initiator/responder side
   * used for a NDP session between two NAN devices
   */
  NanDataPathId ndpInstanceId;
  /**
   * NDI mac address of the peer.
   * (required to derive target ipv6 address)
   */
  MacAddress peerNdiMacAddr;
  /**
   * App/Service information of Initiator/Responder.
   */
  NanDataPathAppInfo appInfo;
  /**
   * Response code indicating ACCEPT/REJECT/DEFER.
   */
  NanDataPathResponseCode rspCode;
  /**
   * Reason code indicating the cause for REJECT.
   */
  NanStatusType reasonCode;
};

/**
 * NAN Data path end Indication Message structure.
 * Event indication received on the initiator/responder side terminating
 * a NDP session
 */
struct NanDataPathEndInd {
  /**
   * Unique token Id generated on the initiator/responder side
   * used for a NDP session between two NAN devices
   */
  vec<NanDataPathId> ndpInstanceIds;
};

/**
 * NAN Transmit followup Indication Message structure.
 * Event Indication notifying the transmit followup in progress.
 */
struct NanTransmitFollowupInd {
  CommandId cmdId;
  NanStatusType reason;
};

/**
 * RTT specific types.
 * TODO(b/32159498): Move to a separate rtt_types.hal.
 */
/**
 * Ranging status.
 */
enum RttStatus : uint32_t {
  SUCCESS = 0,
  /** General failure status */
  FAILURE = 1,
  /** Target STA does not respond to request */
  FAIL_NO_RSP = 2,
  /** Request rejected. Applies to 2-sided RTT only */
  FAIL_REJECTED = 3,
  FAIL_NOT_SCHEDULED_YET = 4,
  /** Timing measurement times out */
  FAIL_TM_TIMEOUT = 5,
  /** Target on different channel, cannot range */
  FAIL_AP_ON_DIFF_CHANNEL = 6,
  /** Ranging not supported */
  FAIL_NO_CAPABILITY = 7,
  /** Request aborted for unknown reason */
  ABORTED = 8,
  /** Invalid T1-T4 timestamp */
  FAIL_INVALID_TS = 9,
  /** 11mc protocol failed */
  FAIL_PROTOCOL = 10,
  /** Request could not be scheduled */
  FAIL_SCHEDULE = 11,
  /** Responder cannot collaborate at time of request */
  FAIL_BUSY_TRY_LATER = 12,
  /** Bad request args */
  INVALID_REQ = 13,
  /** WiFi not enabled. */
  NO_WIFI = 14,
  /** Responder overrides param info, cannot range with new params */
  FAIL_FTM_PARAM_OVERRIDE = 15,
};

/**
 * RTT peer types.
 */
enum RttPeerType : uint32_t {
  AP = 0x1,
  STA = 0x2,
  P2P_GO = 0x3,
  P2P_CLIENT = 0x4,
  NAN = 0x5,
};

/**
 * RTT Measurement Bandwidth.
 */
enum RttBw : uint32_t {
  BW_5MHZ = 0x01,
  BW_10MHZ = 0x02,
  BW_20MHZ = 0x04,
  BW_40MHZ = 0x08,
  BW_80MHZ = 0x10,
  BW_160MHZ = 0x20,
};

/**
 * RTT Measurement Preamble.
 */
enum RttPreamble : uint32_t {
  LEGACY = 0x1,
  HT = 0x2,
  VHT = 0x4,
};

/**
 * RTT Types.
 */
enum RttType : uint32_t {
  ONE_SIDED = 0x1,
  TWO_SIDED = 0x2,
};

/**
 * RTT configuration.
 */
struct RttConfig {
  /**
   * Peer device mac address.
   */
  MacAddress addr;
  /**
   * 1-sided or 2-sided RTT.
   */
  RttType type;
  /**
   * Optional - peer device hint (STA, P2P, AP).
   */
  RttPeerType peer;
  /**
   * Required for STA-AP mode, optional for P2P, NBD etc.
   */
  WifiChannelInfo channel;
  /**
   * Time interval between bursts (units: 100 ms).
   * Applies to 1-sided and 2-sided RTT multi-burst requests.
   * Range: 0-31, 0: no preference by initiator (2-sided RTT).
   */
  uint32_t burstPeriod;
  /**
   * Total number of RTT bursts to be executed. It will be
   * specified in the same way as the parameter "Number of
   * Burst Exponent" found in the FTM frame format. It
   * applies to both: 1-sided RTT and 2-sided RTT. Valid
   * values are 0 to 15 as defined in 802.11mc std.
   * 0 means single shot
   * The implication of this parameter on the maximum
   * number of RTT results is the following:
   * for 1-sided RTT: max num of RTT results = (2^num_burst)*(num_frames_per_burst)
   * for 2-sided RTT: max num of RTT results = (2^num_burst)*(num_frames_per_burst - 1)
   */
  uint32_t numBurst;
  /**
   * Num of frames per burst.
   * Minimum value = 1, Maximum value = 31
   * For 2-sided this equals the number of FTM frames
   * to be attempted in a single burst. This also
   * equals the number of FTM frames that the
   * initiator will request that the responder send
   * in a single frame.
   */
  uint32_t numFramesPerBurst;
  /**
   * Number of retries for a failed RTT frame.
   * Applies to 1-sided RTT only. Minimum value = 0, Maximum value = 3
   */
  uint32_t numRetriesPerRttFrame;
  /** Following fields are only valid for 2-side RTT. */
  /**
   * Maximum number of retries that the initiator can
   * retry an FTMR frame.
   * Minimum value = 0, Maximum value = 3
   */
  uint32_t numRetriesPerFtmr;
  /**
   * Whether to request location civic info or not.
   */
  bool mustRequestLci;
  /**
   * Whether to request location civic records or not.
   */
  bool mustRequestLcr;
  /**
   * Applies to 1-sided and 2-sided RTT. Valid values will
   * be 2-11 and 15 as specified by the 802.11mc std for
   * the FTM parameter burst duration. In a multi-burst
   * request, if responder overrides with larger value,
   * the initiator will return failure. In a single-burst
   * request if responder overrides with larger value,
   * the initiator will sent TMR_STOP to terminate RTT
   * at the end of the burst_duration it requested.
   */
  uint32_t burstDuration;
  /**
   * RTT preamble to be used in the RTT frames.
   */
  RttPreamble preamble;
  /**
   * RTT BW to be used in the RTT frames.
   */
  RttBw bw;
};

/**
 * RTT results.
 */
struct RttResult {
  /**
   * Peer device mac address.
   */
  MacAddress addr;
  /**
   * Burst number in a multi-burst request.
   */
  uint32_t burstNum;
  /**
   * Total RTT measurement frames attempted.
   */
  uint32_t measurementNumber;
  /**
   * Total successful RTT measurement frames.
   */
  uint32_t successNumber;
  /**
   * Maximum number of "FTM frames per burst" supported by
   * the responder STA. Applies to 2-sided RTT only.
   * If reponder overrides with larger value:
   * - for single-burst request initiator will truncate the
   * larger value and send a TMR_STOP after receiving as
   * many frames as originally requested.
   * - for multi-burst request, initiator will return
   * failure right away.
   */
  uint8_t numberPerBurstPeer;
  /**
   * Ranging status.
   */
  RttStatus status;
  /**
   * When status == RTT_STATUS_FAIL_BUSY_TRY_LATER,
   * this will be the time provided by the responder as to
   * when the request can be tried again. Applies to 2-sided
   * RTT only. In sec, 1-31sec.
   */
  uint8_t retryAfterDuration;
  /**
   * RTT type.
   */
  RttType type;
  /**
   * Average rssi in 0.5 dB steps e.g. 143 implies -71.5 dB.
   */
  Rssi rssi;
  /**
   * Rssi spread in 0.5 dB steps e.g. 5 implies 2.5 dB spread (optional).
   */
  Rssi rssiSpread;
  /**
   * 1-sided RTT: TX rate of RTT frame.
   * 2-sided RTT: TX rate of initiator's Ack in response to FTM frame.
   */
  WifiRateInfo txRate;
  /**
   * 1-sided RTT: TX rate of Ack from other side.
   * 2-sided RTT: TX rate of FTM frame coming from responder.
   */
  WifiRateInfo rxRate;
  /**
   * Round trip time in picoseconds
   */
  TimeSpanInPs rtt;
  /**
   * Rtt standard deviation in picoseconds.
   */
  TimeSpanInPs rttSd;
  /**
   * Difference between max and min rtt times recorded in picoseconds.
   */
  TimeSpanInPs rttSpread;
  /**
   * Distance in mm (optional).
   */
  int32_t distanceInMm;
  /**
   * Standard deviation in mm (optional).
   */
  int32_t distanceSdInMm;
  /**
   * Difference between max and min distance recorded in mm (optional).
   */
  int32_t distanceSpreadInMm;
  /**
   * Time of the measurement (in microseconds since boot).
   */
  TimeStampInUs timeStampInUs;
  /**
   * in ms, actual time taken by the FW to finish one burst
   * measurement. Applies to 1-sided and 2-sided RTT.
   */
  uint32_t burstDurationInMs;
  /**
   * Number of bursts allowed by the responder. Applies
   * to 2-sided RTT only.
   */
  uint32_t negotiatedBurstNum;
  /**
   * for 11mc only.
   */
  WifiInformationElement lci;
  /**
   * for 11mc only.
   */
  WifiInformationElement lcr;
};

/**
 * RTT Capabilities.
 */
struct RttCapabilities {
  /**
   * if 1-sided rtt data collection is supported.
   */
  bool rttOneSidedSupported;
  /**
   * if ftm rtt data collection is supported.
   */
  bool rttFtmSupported;
  /**
   * if initiator supports LCI request. Applies to 2-sided RTT.
   */
  bool lciSupported;
  /**
   * if initiator supports LCR request. Applies to 2-sided RTT.
   */
  bool lcrSupported;
  /**
   * if 11mc responder mode is supported.
   */
  bool responderSupported;
  /**
   * Bit mask indicates what preamble is supported by initiator.
   * Combination of |RttPreamble| values.
   */
  uint8_t preambleSupport;
  /**
   * Bit mask indicates what BW is supported by initiator.
   * Combination of |RttBw| values.
   */
  uint8_t bwSupport;
  /**
   * Draft 11mc spec version supported by chip.
   * For instance, version 4.0 must be 40 and version 4.3 must be 43 etc.
   */
  uint8_t mcVersion;
};

/**
 * Structs for setting LCI/LCR information to be provided to a requestor.
 */
enum RttMotionPattern : uint32_t {
  /**
   * Not expected to change location.
   */
  NOT_EXPECTED = 0,
  /**
   * Expected to change location.
   */
  EXPECTED = 1,
  /**
   * Movement pattern unknown.
   */
  UNKNOWN = 2,
};

/**
 * Movement pattern unknown.
 */
struct RttLciInformation {
  /**
   * latitude in degrees * 2^25 , 2's complement.
   */
  int64_t latitude;
  /**
   * longitude in degrees * 2^25 , 2's complement.
   */
  int64_t longitude;
  /**
   * Altitude in units of 1/256 m.
   */
  int32_t altitude;
  /**
   * As defined in Section 2.3.2 of IETF RFC 6225.
   */
  uint8_t latitudeUnc;
  /**
   * As defined in Section 2.3.2 of IETF RFC 6225.
   */
  uint8_t longitudeUnc;
  /**
   * As defined in Section 2.4.5 from IETF RFC 6225.
   */
  uint8_t altitudeUnc;
  /** Following element for configuring the Z subelement. */
  /**
   * Motion pattern type.
   */
  RttMotionPattern motionPattern;
  /**
   * Floor in units of 1/16th of floor. 0x80000000 if unknown.
   */
  int32_t floor;
  /**
   * in units of 1/64 m.
   */
  int32_t heightAboveFloor;
  /**
   * in units of 1/64 m. 0 if unknown
   */
  int32_t heightUnc;
};

struct RttLcrInformation {
  /**
   * Country code symbol.
   */
  int8_t[2] countryCode;
  /**
   * Civic info to be copied in FTM frame.
   */
  string civicInfo;
};

/***
 * RTT Responder information
 */
struct RttResponder {
  WifiChannelInfo channel;
  RttPreamble preamble;
};

/**
 * Debug data specific types.
 * TODO(b/32159498): Move to a separate debug_types.hal.
 */
typedef uint32_t WifiRingBufferId;

/**
 * Flags describing each debug ring buffer.
 */
enum WifiDebugRingBufferFlags : uint32_t {
  HAS_BINARY_ENTRIES = 1 << 0,
  HAS_ASCII_ENTRIES = 1 << 1,
  HAS_PER_PACKET_ENTRIES = 1 << 2,
};

/**
 * Struct describing each debug ring buffer supported by
 * the device.
 */
struct WifiDebugRingBufferStatus {
  /**
   * Name of this debug ring buffer.
   */
  string ringName;
  /**
   * Combination of |WifiDebugRingBufferFlags| values.
   */
  uint32_t flags;
  /**
   * Unique integer representing the ring.
   */
  WifiRingBufferId ringId;
  /**
   * Total memory size allocated for the buffer.
   */
  uint32_t sizeInBytes;
  /**
   * Amount of free space in the buffer.
   */
  uint32_t freeSizeInBytes;
  /**
   * Verbose level for ring buffer.
   */
  uint32_t verboseLevel;
};

/**
 * Verbose logging level to set for each debug ring buffer supported
 * by the device.
 */
enum WifiDebugRingBufferVerboseLevel : uint32_t {
  /**
   * Level 0 corresponds to no collection, and it makes log handler
   * stop by no more events from driver.
   */
  NONE = 0,
  /**
   * Level 1 correspond to normal log level, with minimal user impact.
   * This is the default value.
   */
  DEFAULT = 1,
  /**
   * Level 2 is enabled when user is lazily trying to reproduce a problem,
   * wifi performances and power can be impacted but device should not
   * otherwise be significantly impacted.
   */
  VERBOSE = 2,
  /**
   * Level 3 is used when trying to actively debug a problem.
   * This will cause sever performance degradation.
   */
  EXCESSIVE = 3
};

/**
 * Enum describing the fate of the TX packets.
 */
enum WifiDebugTxPacketFate : uint32_t {
  /**
   * Sent over air and ACKed.
   */
  ACKED,
  /**
   * Sent over air but not ACKed. (Normal for broadcast/multicast.)
   */
  SENT,
  /**
   * Queued within firmware, but not yet sent over air.
   */
  FW_QUEUED,
  /**
   * Dropped by firmware as invalid. E.g. bad source address, bad checksum,
   * or invalid for current state.
   */
  FW_DROP_INVALID,
  /**
   * Dropped by firmware due to lack of buffer space.
   */
  FW_DROP_NOBUFS,
  /**
   * Dropped by firmware for any other reason. Includes frames that  were sent
   * by driver to firmware, but unaccounted for by  firmware.
   */
  FW_DROP_OTHER,
  /**
   * Queued within driver, not yet sent to firmware.
   */
  DRV_QUEUED,
  /**
   * Dropped by driver as invalid. E.g. bad source address, or invalid for
   * current state.
   */
  DRV_DROP_INVALID,
  /**
   * Dropped by driver due to lack of buffer space.
   */
  DRV_DROP_NOBUFS,
  /**
   * Dropped by driver for any other reason.
   */
  DRV_DROP_OTHER,
};

/**
 * Enum describing the fate of the TX packets.
 */
enum WifiDebugRxPacketFate : uint32_t {
  /**
   * Valid and delivered to network stack (e.g., netif_rx()).
   */
  SUCCESS,
  /**
   * Queued within firmware, but not yet sent to driver.
   */
  FW_QUEUED,
  /**
   * Dropped by firmware due to host-programmable filters.
   */
  FW_DROP_FILTER,
  /**
   * Dropped by firmware as invalid. E.g. bad checksum, decrypt failed,
   * or invalid for current state.
   */
  FW_DROP_INVALID,
  /**
   * Dropped by firmware due to lack of buffer space.
   */
  FW_DROP_NOBUFS,
  /**
   * Dropped by firmware for any other reason.
   */
  FW_DROP_OTHER,
  /**
   * Queued within driver, not yet delivered to network stack.
   */
  DRV_QUEUED,
  /**
   * Dropped by driver due to filter rules.
   */
  DRV_DROP_FILTER,
  /**
   * Dropped by driver as invalid. E.g. not permitted in current state.
   */
  DRV_DROP_INVALID,
  /**
   * Dropped by driver due to lack of buffer space.
   */
  DRV_DROP_NOBUFS,
  /**
   * Dropped by driver for any other reason.
   */
  DRV_DROP_OTHER,
};

/**
 * Type of frame transmitted/received.
 */
enum WifiDebugPacketFateFrameType : uint32_t {
  UNKNOWN,
  ETHERNET_II,
  MGMT_80211,
};

/**
 * Information regarding the frame transmitted/received.
 */
struct WifiDebugPacketFateFrameInfo {
  /**
   * The type of MAC-layer frame that this frame_info holds.
   * - For data frames, use FRAME_TYPE_ETHERNET_II.
   * - For management frames, use FRAME_TYPE_80211_MGMT.
   * - If the type of the frame is unknown, use FRAME_TYPE_UNKNOWN.
   */
  WifiDebugPacketFateFrameType frameType;
  /**
   * The number of bytes included in |frameContent|.
   * If the frame  contents are missing (e.g. RX frame dropped in firmware),
   * |frameLen| must be set to 0.
   */
  uint64_t frameLen;
  /**
   * Host clock when this frame was received by the driver (either  outbound
   * from the host network stack, or inbound from the firmware).
   * - The timestamp must be taken from a clock which includes time the host
   *   spent suspended (e.g. ktime_get_boottime()).
   * - If no host timestamp is available (e.g. RX frame was dropped in firmware),
   *   this field must be set to 0.
   */
  TimeStampInUs driverTimestampUsec;
  /**
   * Firmware clock when this frame was received by the firmware
   * (either outbound from the host, or inbound from a remote  station).
   * - The timestamp must be taken from a clock which includes time firmware
   *   spent suspended (if applicable).
   * - If no firmware timestamp is available (e.g. TX frame was dropped by
   *   driver), this field must be set to 0.
   * - Consumers of |frameInfo| must not assume any synchronization between
   *   driver and firmware clocks.
   */
  TimeStampInUs firmwareTimestampUsec;
  /**
   * Actual frame content. This is the raw bytes of the corresponding packet.
   * - Should be provided for TX frames originated by the host.
   * - Should be provided for RX frames received by the driver.
   * - Optionally provided for TX frames originated by firmware.
   *   (At discretion of HAL implementation.)
   * - Optionally provided for RX frames dropped in firmware.
   *   (At discretion of HAL implementation.)
   * - If frame content is not provided, |frameLen| must be set to 0.
   */
  vec<uint8_t> frameContent;
};

/**
 * Struct describing packet fate report for each Rx frame.
 */
struct WifiDebugTxPacketFateReport {
  WifiDebugTxPacketFate fate;
  WifiDebugPacketFateFrameInfo frameInfo;
};

/**
 * Struct describing packet fate report for each Rx frame.
 */
struct WifiDebugRxPacketFateReport {
  WifiDebugRxPacketFate fate;
  WifiDebugPacketFateFrameInfo frameInfo;
};

/**
 * Struct capturing the count of all rx packets that caused
 * host wakeup.
 */
struct WifiDebugHostWakeReasonRxPacketDetails {
  /**
   * Total rx unicast packet which woke up host.
   */
  uint32_t rxUnicastCnt;
  /**
   * Total rx multicast packet which woke up host.
   */
  uint32_t rxMulticastCnt;
  /**
   * Total rx broadcast packet which woke up host.
   */
  uint32_t rxBroadcastCnt;
};

/**
 * Struct capturing the count of all rx multicast packets that caused
 * host wakeup.
 */
struct WifiDebugHostWakeReasonRxMulticastPacketDetails {
  /**
   * Rx wake packet was ipv4 multicast.
   */
  uint32_t ipv4RxMulticastAddrCnt;
  /**
   * Rx wake packet was ipv6 multicast.
   */
  uint32_t ipv6RxMulticastAddrCnt;
  /**
   * Rx wake packet was non-ipv4 and non-ipv6.
   */
  uint32_t otherRxMulticastAddrCnt;
};

/**
 * Struct capturing the count of all rx ICMP packets that caused
 * host wakeup.
 */
struct WifiDebugHostWakeReasonRxIcmpPacketDetails {
  /**
   * Wake icmp packet count.
   */
  uint32_t icmpPkt;
  /**
   * Wake icmp6 packet count.
   */
  uint32_t icmp6Pkt;
  /**
   * Wake icmp6 RA packet count.
   */
  uint32_t icmp6Ra;
  /**
   * Wake icmp6 NA packet count.
   */
  uint32_t icmp6Na;
  /**
   * Wake icmp6 NS packet count.
   */
  uint32_t icmp6Ns;
};

/**
 * Structure capturing the count of all the wireless related host wakeup.
 * This is used to capture all the reasons why the host processor
 * (WLAN driver) was woken up by the WLAN firmware.
 * These stats may be used to debug any power issues caused due to frequent
 * wakeup of the host processor by the WLAN firmware.
 */
struct WifiDebugHostWakeReasonStats {
  /**
   * Total count of cmd/event wakes.
   * These must account for all wakeups due to WLAN management
   * commands/events received over the air.
   */
  uint32_t totalCmdEventWakeCnt;
  /**
   * Vector of wake counts per cmd/event type.
   * The number of command types and their meaning is only understood by the
   * vendor.
   */
  vec<uint32_t> cmdEventWakeCntPerType;
  /**
   * Total count of drive/fw wakes.
   * These must account for all wakeups due to local driver/firmware
   * interactions. These include all vendor implementation specific
   * interactions like any heart-beat monitoring, Bus management, etc.
   */
  uint32_t totalDriverFwLocalWakeCnt;
  /**
   * Vector of wake counts per driver/firmware interaction type.
   * The number of command types and their meaning is only understood by the
   * vendor.
   */
  vec<uint32_t> driverFwLocalWakeCntPerType;
  /**
   * Total data rx packets, that woke up host.
   */
  uint32_t totalRxPacketWakeCnt;
  WifiDebugHostWakeReasonRxPacketDetails rxPktWakeDetails;
  WifiDebugHostWakeReasonRxMulticastPacketDetails rxMulticastPkWakeDetails;
  WifiDebugHostWakeReasonRxIcmpPacketDetails rxIcmpPkWakeDetails;
};
